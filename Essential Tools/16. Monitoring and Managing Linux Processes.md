#  Monitoring and Managing Linux Processes
 
## Processes and the Process Lifecycle

### Definition of a Process
A process is a running instance of a launched, executable program. From the moment that a process is created, it consists of the following items:

- An address space of allocated memory
- Security properties, including ownership credentials and privileges
- One or more execution threads of program code
- A process state

The environment of a process is a list of information that includes the following items:

- Local and global variables
- A current scheduling context
- Allocated system resources, such as file descriptors and network ports

An existing parent process duplicates its own address space, which is known as a process fork, to create a child process structure. Every new process is assigned a unique process ID (PID) for tracking and security purposes. The PID and the parent's process ID (PPID) are elements of the new process environment. Any process can create a child process. All processes are descendants of the first system process, systemd, on a Red Hat system.


![alt text](images/image18.png)

Through the fork routine, a child process inherits security identities, previous and current file descriptors, port and resource privileges, environment variables, and program code. A child process can then execute its own program code.

Typically, a parent process sleeps when the child process runs, and sets a wait request to be signaled when the child process completes. After the child process exits, it closes or discards its resources and environment, and leaves a zombie resource, which is an entry in the process table. The parent process, which is signaled to wake when the child process exits, cleans the process table of the child's entry, and it frees the last resource of the child process. The parent process then continues with its own program code execution.

### Process States

In a multitasking operating system, each CPU (or CPU core) can work on one process at a time. As a process runs, its immediate requirements for CPU time and resource allocation change. Processes are assigned a state, which changes as circumstances dictate.

The following diagram and table describe Linux process states in detail.

![alt text](images/image19.png)


**Table 15.1. Linux Process States**



| Name     | Flag | Kernel-defined state name and description |
|----------|------|-------------------------------------------|
| **Running** | R | **TASK_RUNNING**: The process is either executing on a CPU or waiting to run. The process can be executing user routines or kernel routines (system calls), or be queued and ready when in the *Running* (or *Runnable*) state. |
| **Sleeping** | S | **TASK_INTERRUPTIBLE**: The process is waiting for some condition: a hardware request, system resource access, or a signal. When an event or signal satisfies the condition, the process returns to *Running*. |
|           | D | **TASK_UNINTERRUPTIBLE**: This process is also sleeping, but unlike the S state, it does not respond to signals. This state is used only when process interruption might cause an unpredictable device state. |
|           | K | **TASK_KILLABLE**: Same as the uninterruptible D state, but modified to allow a waiting task to respond to the signal to kill it (exit completely). Utilities often display *Killable* processes as the D state. |
|           | I | **TASK_REPORT_IDLE**: A subset of state D that is used for kernel threads. The kernel does not count these processes when calculating the load average. The `TASK_UNINTERRUPTIBLE` and `TASK_NOLOAD` flags are set. This state is similar to TASK_KILLABLE, and it accepts fatal signals. |
| **Stopped** | T | **TASK_STOPPED**: The process is stopped (suspended), usually by being signaled by a user or another process. The process can be continued (resumed) by another signal to return to running. |
|           | T | **TASK_TRACED**: A process that is being debugged is also temporarily stopped and shares the T state flag. |
| **Zombie** | Z | **EXIT_ZOMBIE**: A child process signals to its parent as it exits. All resources except for the process identity (PID) are released. |
|           | X | **EXIT_DEAD**: When the parent process cleans up (reaps) the remaining child process structure, the process is now released completely. This state cannot be observed in process-listing utilities. |

