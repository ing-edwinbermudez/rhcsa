# Configuring and Securing SSH

## Managing SSH Host Keys

### The Role of SSH Host Keys

SSH (Secure Shell) creates a secure communication channel primarily through public-key encryption. When an SSH client attempts to connect to an SSH server, the server first sends a copy of its public key to the client. The server's public key is important because the client uses this host key to authenticate the server's identity.

When you run the `ssh` command, your client checks for a record of the server's public key in its local known hosts file. This file can be centrally managed in /etc/ssh/ssh_known_hosts or, more commonly, stored in your user's home directory at ~/.ssh/known_hosts.

If your client already has a copy of the server's public key, then the `ssh` command compares the key that it received from the server with the locally stored one. If these keys do not match, then the client assumes a potential security risk, such as an interceptor or man-in-the-middle attack, and refuses to connect to the host. This strict verification process is a critical layer of security because it prevents your system from unknowingly connecting to a compromised or malicious server.

After the server's identity is successfully verified (or accepted by the user), the connection is deemed trustworthy enough to proceed to the next critical stage: the key exchange. During the key exchange (often by using the Diffie-Hellman method), a temporary, shared secret session key is generated for faster, symmetric encryption of all subsequent communications.

### Strict Host Key Checking on Clients

For security, the SSH client's default setting is to require manual confirmation before a new host key is accepted and stored.

```bash
ssh hostb
```

However, you can adjust this behavior by setting the StrictHostKeyChecking option, either in a configuration file or from the command line.

### Configure Host Key Checking with Configuration Files

You can customize how your SSH client handles host keys by editing one of two configuration files:

- The `/etc/ssh/ssh_config` file configures system-wide SSH client settings.
- The `~/.ssh/config` file configures user-specific SSH client settings.

Keep in mind that any settings in your personal `~/.ssh/config` file override those settings in the system-wide configuration.

To control how your SSH client handles host keys, modify the `StrictHostKeyChecking` parameter in your preferred configuration file. Set the parameter to one of these options

| Option      | Description |
|-------------|-------------|
| **yes**     | The most secure setting. The SSH client always ends the connection if the server's public key does not match the one stored in your `known_hosts` file. You must manually add new host keys to `known_hosts`, since SSH does not do it automatically. Highly secure, but can be inconvenient due to manual key management. |
| **accept-new** | Automatically adds new host keys to `known_hosts` when connecting to a new host. If a host's key has changed, the connection fails, preventing potential security risks. |
| **no**      | The least secure option. SSH automatically adds new host keys without prompting and allows connections even if a host's key has changed, which increases vulnerability to interceptor attacks. |
| **ask**     | The default and recommended setting. SSH prompts for confirmation before adding a new host key. If a host's key has changed, SSH refuses the connection and alerts you, preventing compromised connections. |


### Configure Host Key Checking from the Command Line

You can also set the `StrictHostKeyChecking` parameter from the command line by specifying the `-o StrictHostKeyChecking` option when you run the `ssh` command. The option uses the same settings as the configuration file parameter.

Command-line options always take precedence over settings in both your personal `~/.ssh/config` file and the system-wide `/etc/ssh/ssh_config` file. This precedence means that you can temporarily adjust host key checking behavior for a single connection without altering your permanent configuration.

For example, to connect to a new host and to automatically accept its host key (which is generally discouraged for security reasons unless you are certain of the host's authenticity), you could use the following command:

```bash
ssh -o StrictHostKeyChecking=accept-new hostb
```

## Verifying SSH Host Key Fingerprints

To ensure the authenticity of a target SSH server and to protect against interceptor attacks, the client must verify the host's public key. However, SSH public keys are long, complex strings of characters that are typically Base64-encoded. Trying to manually compare or verify a key against a trusted source is error-prone and impractical.

An SSH host key fingerprint is a short, cryptographic hash of the server's public key that enables the SSH client (and user) to confirm that they are connecting to the intended, legitimate server and not to an imposter. Fingerprints are easier for a human to visually inspect and compare.

An SSH host key fingerprint is a short, cryptographic hash of the server's public key that enables the SSH client (and user) to confirm that they are connecting to the intended, legitimate server and not to an imposter. Fingerprints are easier for a human to visually inspect and compare.

On the SSH server, use the `ssh-keygen` command to display its public key fingerprint:

```bash
ssh-keygen -l -f /etc/ssh/ssh_host_ed25519_key.pub
```

You might have to adjust the path to the public key file if your server uses a different algorithm such as RSA or ECDSA.

After you verify the server's public key fingerprint, you must securely communicate this fingerprint to the client-side administrator by using a trusted alternative communication method, such as a phone call or video conference.

The client-side administrator must compare this received fingerprint with the one that the ssh command presents when they first attempt to connect. If the fingerprints match, then the server's identity is confirmed and the connection can proceed. If the fingerprints do not match, then the connection should be stopped because of a potential security risk.

In the following example, the user must carefully compare the fingerprint of the SSH server with a trusted source, before typing yes to proceed with the connection.

```bash
user@host:~$ ssh hostb
The authenticity of host 'hostb (192.168.250.11)' can't be established.
ED25519 key fingerprint is SHA256:Qit7NeebQCgP2otXSaVXbw1rGmUVMlybXyV68qaND/M.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added 'hostb' (ED25519) to the list of known hosts.
user@hostb's password: password
...output omitted...
```

## Regenerating SSH Host Keys on Servers

You might want to regenerate SSH host keys for security reasons, such as if you suspect that a key is compromised or if you are creating a new server image and need unique identifiers for each instance

Starting in Red Hat Enterprise Linux 10, the SSH server by default uses three pairs of keys and the ED25519, ECDSA, and RSA host key algorithms. These host key files are in the `/etc/ssh/` directory on the server:

```bash
ls -l /etc/ssh/ssh_host_*
```

If you need to generate new SSH host key pairs, then delete the existing key pairs and restart the SSH daemon. The `sshd.service` unit automatically detects the absence of these keys during service start and regenerates all three key pairs.

```bash
rm -f /etc/ssh/ssh_host_*
systemctl restart sshd.service
```

**Note**

    On systems that use the Cloud-init package, Cloud-init is typically responsible for managing SSH host key generation as part of its instance provisioning process. As a result, SSH host key pairs might not regenerate automatically, or Cloud-init might overwrite any manually generated keys during subsequent provisioning steps.

## Managing Known Host Files on Clients

After regenerating host keys, for any SSH client that previously connected to your server, the earlier host key is still stored in its known_hosts file. When these clients attempt to connect again, they receive a warning about a potential interceptor attack because the server's identity no longer matches what the client expects.

```bash
user@host:~$ ssh user@hostb
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ED25519 key sent by the remote host is
SHA256:0sQuJcXztSoxwi+2hNrj6iRYQpjq2kXSCzcZA8m5Izs.
Please contact your system administrator.
Add correct host key in /home/user/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /home/user/.ssh/known_hosts:3
Host key for hostb has changed and you have requested strict checking.
Host key verification failed.
user@host:~$
```

SSH clients keep a list of known remote systems and their corresponding host keys in one of two locations:

- The `/etc/ssh/ssh_known_hosts` file

    This system-wide file is not present by default; a system administrator must create it and add trusted host keys to it. It stores public keys for hosts that are known to the entire system, which means that it benefits all users on the system. By prepopulating this file, administrators help users to avoid the dilemma of trusting a new, unknown host key, which is especially beneficial in large environments.

- The `~/.ssh/known_hosts` file
    This user-specific file is in the home directory of each user. If the SSH client does not find a remote system's public key in the system-wide known hosts file, then it then looks for the key in the user's file. By default, SSH automatically adds a server's host key to this file the first time that a user connects and accepts it. Users can, however, configure their SSH client to prevent this automatic addition.

If a remote server's host key changes, then you can remove the outdated entry from your `~/.ssh/known_hosts` file. You can update this file by using a text editor to delete the line that corresponds to the changed host, or by using the `ssh_keygen` utility, which is the safer option.

For example, to remove a key entry for hostb, you can run the command with the -R option:

```bash
ssh-keygen -R hostb
```

If the offending key is present in the system-wide known hosts file, then the administrator must delete the matching entry:

```bash
ssh-keygen -R hostb -f /etc/ssh/ssh_known_hosts
```

The previous command identified three matching key entries for the host and deleted the lines.

## Populating Known Host Files

The `ssh-keyscan` command is a valuable tool for collecting the public host keys of remote servers. You can use this command to manually populate `known_hosts` files, which is particularly useful for scripting, automation, or setting up a system-wide `ssh_known_hosts` file.

To retrieve and save the public key of a remote host, append the output of the `ssh-keyscan` command to your personal known hosts file:

```bash
ssh-keyscan hostb >> ~/.ssh/known_hosts
```

Be default, the command saves all key pairs that the server might have presented. You can verify the fingerprint of your stored host keys by using the `ssh-keygen` command:

```bash
ssh-keygen -l -f ~/.ssh/known_hosts
```

You can also open the known hosts file in a text editor to view complete public keys instead of just their fingerprints.

A system administrator might use the `ssh-keyscan` command to add a new host to the system-wide known hosts file. The following command demonstrates that the tool can also operate in quiet mode (-q) and collect specific types (-t) of host keys:

```bash
ssh-keyscan -q -t ed25519 hostb >> /etc/ssh/ssh_known_hosts
```

Another valid scenario is for the system administrator to use the `ssh-keyscan` command to scan an entire network segment for host keys. This approach can be useful for quickly gathering keys from a range of servers in a controlled environment

For example, you can scan a range of IP addresses to collect RSA host keys:

```bash
ssh-keyscan -q -t rsa 172.25.250.0/24 >> /etc/ssh/ssh_known_hosts
```

**Warning**

    Although the ssh-keyscan command is convenient, you must exercise caution, especially when scanning an entire network. When using the ssh-keyscan command, you are trusting the key that is presented by the remote server at that moment. On an untrusted network, where a server's identity might be spoofed, you should verify the retrieved key's fingerprint through an alternative method before adding it to your known_hosts file. Directly appending the ssh-keyscan command output to a known_hosts file without verification can expose you to interceptor attacks.

---
# Configuring SSH Key-based Authentication
---

## SSH Key-based Authentication

Passwords can be learned or stolen, but securely stored private keys are harder to compromise. You can configure user accounts for passwordless access to SSH servers by enabling key-based authentication, which is based on public key encryption (PKI).

Prepare your account by generating a cryptographically related pair of key files. One key is private and is held only by you, and the other key is public, and is not secret. The private key acts as your authentication credential, and it must be stored securely. The public key is copied to your account on remote servers and verifies your private key during authentication.

When you log in to a remote server, the remote server encrypts a challenge message by using your public key and sends it to your SSH client. Your SSH client proves ownership of the corresponding private key by decrypting the message. If the verification succeeds, then the server trusts your request and grants access without requiring a password.

## Generating SSH Keys

Red Hat Enterprise Linux 10 uses the Ed25519 algorithm by default to create SSH key files. Ed25519 uses a more sophisticated algorithm than the RSA algorithm, which makes the Ed25519 public key shorter, but it still provides strong security and high performance. You can create earlier key types such as RSA; these keys remain functional if the remote SSH server accepts them.

Note

    RSA is the default algorithm when the system runs in Federal Information Processing Standard (FIPS) mode.

Use the `ssh-keygen` command to create an SSH key pair. The ssh-keygen command stores the keys in the `~/.ssh/id_ed25519` and `~/.ssh/id_ed25519.pub` files by default. The following example creates a key pair with the default key type, saves the keys to the default location, and does not define a passphrase.

```bash
user@host:~$ ssh-keygen

Generating public/private ed25519 key pair.
Enter file in which to save the key (/home/user/.ssh/id_ed25519): Enter
Created directory '/home/user/.ssh'.
Enter passphrase for "/home/user/.ssh/id_ed25519" (empty for no passphrase): Enter
Enter same passphrase again: Enter
Your identification has been saved in /home/user/.ssh/id_ed25519
Your public key has been saved in /home/user/.ssh/id_ed25519.pub
The key fingerprint is:
SHA256:+w3lTa7BdiZwVO1AuAP9GjlwRdzwqk+JKcrhosmftuM user@host.lab.example.com
The key's randomart image is:
+--[ED25519 256]--+
|           . **+ |
|          o +.o.o|
|           +.+ o.|
|           .* ...|
|        S . o=o  |
|         . *.B . |
|        o o X B  |
|   . .++ + = O   |
|    +=E++ . o .  |
+----[SHA256]-----+
```

You can define a passphrase to encrypt your private key. When a passphrase is set, you must enter the passphrase each time that you use the private key. The passphrase decrypts the private key locally and is never transmitted over the network, unlike a password. A passphrase is recommended to prevent unauthorized use of your private key.

The `ssh-keygen -f` command specifies the file path to store the key pair. The following example creates the private key at `/home/user/.ssh/key-with-pass`, secures the key with the my-secret passphrase, and creates the corresponding public key at `/home/user/.ssh/key-with-pass.pub`.

```bash
ssh-keygen -f .ssh/key-with-pass
```

Warning

    If you use the `ssh-keygen` command and specify the name of an existing key pair, then you overwrite that key pair. This behavior includes the default id_ed25519 files. You can restore the original key pair only if you have a backup. Overwriting a key pair deletes the original private key, which is required to access accounts that use the matching public key.

    If you cannot restore your private key, then you lose access to those remote servers. You must then distribute a new public key to each server to regain access. Always create backups of your keys to prevent permanent loss.

By default, SSH stores generated keys in the `.ssh` subdirectory of your home directory. The private key must be readable and writable only by its owner, so the 600 octal permission is set. The public key is not confidential, and others on the system can read it, so it has 644 octal permissions.

## Sharing the Public Key

Configure your remote account access by copying your public key to the remote system. The `ssh-copy-id` command transfers the public SSH key to the remote system. The `ssh-copy-id` command uses the default `~/.ssh/id_ed25519.pub` file if you do not specify one. If the remote server does not have a public key already configured, then the system prompts you to enter the remote user's password.

The following example uses the `-i` option to send the `.ssh/key-with-pass.pub` public key to the user account on the remotehost machine. The system prompts you to enter the remote user's password, which is user-password in this example.

```bash
ssh-copy-id -i .ssh/key-with-pass.pub user@remotehost
```

After you add the public key, test the remote access with the corresponding private key. If the configuration is correct, then you can access your account on the remote system without being prompted for your account password. If you do not specify a private key file, then the ssh command uses the default `~/.ssh/id_ed25519` file if it exists.

If you configured a passphrase to protect your private key, then SSH requests the passphrase on first use. However, if the key authentication succeeds, then you are not asked for your account password.

The following example uses the `.ssh/key-with-pass` private key to authenticate on the remotehost machine with the user account. The system prompts you to enter the passphrase for the key, which is my-secret in this example.

```bash
ssh -i .ssh/key-with-pass user@remotehost
```

## Noninteractive Authentication with the `ssh-agent` Key Manager

If you encrypt your private key with a passphrase, then you must enter the passphrase each time that you use the private key for authentication. However, you can configure the `ssh-agent`  key manager to cache passphrases. Then, each time that you use SSH, the `ssh-agent` key manager provides the passphrase for you. This approach improves convenience and security by reducing passphrase exposure.

The `ssh-agent` key manager can be configured to start automatically when you log in to a graphical desktop session or a terminal shell. The GNOME graphical desktop environment starts and configures the ssh-agent key manager automatically. If you log in to a text environment, then you must start the ssh-agent program manually for each session. Start the ssh-agent program with the following command:

```bash
eval $(ssh-agent)
```

The `ssh-agent` command runs additional shell commands to set environment variables when it is started manually. These environment variables are required when using the `ssh-add` command. You can load your private key passphrase into the key manager by using the ssh-add command.

The following examples use the ssh-add command to add the private keys from the default `~/.ssh/id_ed25519` file, and then add a private key from the `~/.ssh/key-with-pass` file:


```bash
ssh-add
ssh-add .ssh/key-with-pass
```

The `-l` option of the `ssh-add` command lists the fingerprints of all SSH keys that are currently loaded in the `ssh-agent` key manager.

```bash
ssh-add -l
```

The following ssh command uses the `~/.ssh/key-with-pass` private key to access your account on the remote server. The private key in this example was previously decrypted and added to the `ssh-agent` key manager; therefore the ssh command does not prompt you for the passphrase to decrypt the private key.

```bash
ssh -i .ssh/key-with-pass user@remotehost
```

When you log out of a session that used the ssh-agent key manager, all cached passphrases are cleared from memory.


## SSH Connection Troubleshooting

SSH can appear complex when remote access with key pair authentication is not succeeding. The `ssh` command provides three verbosity levels with the `-v`, `-vv`, and `-vvv` options, which respectively provide increasing debugging information.

This example demonstrates the information that is provided when using the lowest verbosity option:

```bash
ssh -v user@remotehost
```

```bash
OpenSSH_9.9p1, OpenSSL 3.2.2 4 Jun 2024 1
debug1: Reading configuration data /etc/ssh/ssh_config 2
debug1: Reading configuration data /etc/ssh/ssh_config.d/01-training.conf
debug1: /etc/ssh/ssh_config.d/01-training.conf line 1: Applying options for *
debug1: Reading configuration data /etc/ssh/ssh_config.d/50-redhat.conf
...output omitted...
debug1: Connecting to remotehost [192.168.1.10] port 22. 3
debug1: Connection established.
...output omitted...
debug1: Authenticating to remotehost:22 as 'user' 4
...output omitted...
debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic,password 5
...output omitted...
debug1: Next authentication method: publickey 6
debug1: Offering public key: /home/user/.ssh/id_ed25519 ED25519 SHA256:+w3lTa7BdiZwVO1AuAP9GjlwRdzwqk+JKcrhosmftuM 7
debug1: Server accepts key: /home/user/.ssh/id_ed25519 ED25519 SHA256:+w3lTa7BdiZwVO1AuAP9GjlwRdzwqk+JKcrhosmftuM 8
Authenticated to remotehost ([192.168.1.10]:22) using "publickey".
...output omitted...
user@remotehost:~$
```

If an attempted authentication method fails, then a remote SSH server falls back to other allowed authentication methods, until all the available methods are tried. The next example demonstrates a remote access with an SSH key that fails, but then the SSH server offers password authentication that succeeds.

```bash
ssh -v user@remotehost
```
```bash
...output omitted...
debug1: Next authentication method: publickey
debug1: Offering public key: /home/user/.ssh/id_ed25519 ED25519 SHA256:+w3lTa7BdiZwVO1AuAP9GjlwRdzwqk+JKcrhosmftuM
debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic,password
...output omitted...
debug1: Next authentication method: password
user@remotehost's password: user-password
Authenticated to remotehost ([172.25.250.10]:22) using "password".
...output omitted...
user@remotehost:~$
```

## Configuring an SSH Client

You can create the `~/.ssh/config` file to preconfigure SSH connections. Within the configuration file, you can specify connection parameters such as users, keys, and ports for specific hosts. This file eliminates the need to manually specify command parameters each time that you connect to a host. Consider the following `~/.ssh/config` file, which preconfigures two host connections with different users and keys:

```bash
cat ~/.ssh/config
```

## Configuring an SSH Server

The `sshd` daemon provides the OpenSSH service. You can configure the service by editing the `/etc/ssh/sshd_config` file.

The default configuration of the OpenSSH server works well for many use cases. However, you might make changes to strengthen the security of your system. For example, you might want to prohibit direct remote logins to the root account, and to prohibit password-based authentication (in favor of SSH private key authentication).

### Prohibiting the Superuser from Logging In

- The `root` username exists on every Linux system by default, so a potential attacker needs only to guess the password, instead of a valid username and password combination. Using a valid username and password reduces the likelihood of a successful attack.
- The `root` user has unrestricted privileges, so its compromise can lead to maximum damage to the system.
- From an auditing perspective, tracking which authorized user logged in as the `root` user and made changes can be difficult. If users must log in as a regular user and switch to the root account, then you can view a log event for accountability.

Important

    Starting in Red Hat Enterprise Linux 9, the `PermitRootLogin` parameter is set to the prohibit-password value by default. This value enforces the use of key-based authentication instead of passwords for logging in as the root user, and reduces the risk of brute-force attacks.

The OpenSSH server uses the `PermitRootLogin` configuration setting in the `/etc/ssh/sshd_config` file to allow or prohibit users to log in to the system as the root user, as in the following example:

```bash
PermitRootLogin yes
```

If the `PermitRootLogin` parameter is set to yes, then anyone can log in as the `root` user remotely. To prevent this situation, set the value to no.

Alternatively, to prevent password-based authentication but to allow private key-based authentication for the root user, set the PermitRootLogin parameter to without-password.

You must reload the sshd service to apply the changes.

```bash
systemctl reload sshd
```

### Prohibiting Password-based Authentication

Allowing only private key-based authentication has the following advantages:

- Attackers cannot use password-guessing attacks to remotely break into known accounts on the system.
- With passphrase-protected private keys, an attacker needs both the passphrase and a copy of the private key. With passwords, an attacker needs only the password.
- By using passphrase-protected private keys with the ssh-agent key manager, the passphrase is entered and exposed less often, and logging in is more convenient for the user.

SSH uses the `PasswordAuthentication` parameter in the `/etc/ssh/sshd_config` file to control whether users can use password-based authentication to log in to the system.

```bash
PasswordAuthentication yes
```

With the default value of yes for the `PasswordAuthentication` parameter in the `/etc/ssh/sshd_config` file, the SSH server allows users to use password-based authentication when logging in. The value of no for `PasswordAuthentication` prevents users from using password-based authentication.

Whenever you change the `/etc/ssh/sshd_config` file, you must reload the sshd service to apply the changes.


Important

    If you turn off password-based authentication for SSH, then you must ensure that the user's `~/.ssh/authorized_keys` file on the remote server is populated with their public key, so that they can log in.

