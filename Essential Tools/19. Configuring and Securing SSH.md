# Configuring and Securing SSH

## Managing SSH Host Keys

### The Role of SSH Host Keys

SSH (Secure Shell) creates a secure communication channel primarily through public-key encryption. When an SSH client attempts to connect to an SSH server, the server first sends a copy of its public key to the client. The server's public key is important because the client uses this host key to authenticate the server's identity.

When you run the `ssh` command, your client checks for a record of the server's public key in its local known hosts file. This file can be centrally managed in /etc/ssh/ssh_known_hosts or, more commonly, stored in your user's home directory at ~/.ssh/known_hosts.

If your client already has a copy of the server's public key, then the `ssh` command compares the key that it received from the server with the locally stored one. If these keys do not match, then the client assumes a potential security risk, such as an interceptor or man-in-the-middle attack, and refuses to connect to the host. This strict verification process is a critical layer of security because it prevents your system from unknowingly connecting to a compromised or malicious server.

After the server's identity is successfully verified (or accepted by the user), the connection is deemed trustworthy enough to proceed to the next critical stage: the key exchange. During the key exchange (often by using the Diffie-Hellman method), a temporary, shared secret session key is generated for faster, symmetric encryption of all subsequent communications.

### Strict Host Key Checking on Clients

For security, the SSH client's default setting is to require manual confirmation before a new host key is accepted and stored.

```bash
ssh hostb
```

However, you can adjust this behavior by setting the StrictHostKeyChecking option, either in a configuration file or from the command line.

### Configure Host Key Checking with Configuration Files

You can customize how your SSH client handles host keys by editing one of two configuration files:

- The `/etc/ssh/ssh_config` file configures system-wide SSH client settings.
- The `~/.ssh/config` file configures user-specific SSH client settings.

Keep in mind that any settings in your personal `~/.ssh/config` file override those settings in the system-wide configuration.

To control how your SSH client handles host keys, modify the `StrictHostKeyChecking` parameter in your preferred configuration file. Set the parameter to one of these options

| Option      | Description |
|-------------|-------------|
| **yes**     | The most secure setting. The SSH client always ends the connection if the server's public key does not match the one stored in your `known_hosts` file. You must manually add new host keys to `known_hosts`, since SSH does not do it automatically. Highly secure, but can be inconvenient due to manual key management. |
| **accept-new** | Automatically adds new host keys to `known_hosts` when connecting to a new host. If a host's key has changed, the connection fails, preventing potential security risks. |
| **no**      | The least secure option. SSH automatically adds new host keys without prompting and allows connections even if a host's key has changed, which increases vulnerability to interceptor attacks. |
| **ask**     | The default and recommended setting. SSH prompts for confirmation before adding a new host key. If a host's key has changed, SSH refuses the connection and alerts you, preventing compromised connections. |


### Configure Host Key Checking from the Command Line

You can also set the `StrictHostKeyChecking` parameter from the command line by specifying the `-o StrictHostKeyChecking` option when you run the `ssh` command. The option uses the same settings as the configuration file parameter.

Command-line options always take precedence over settings in both your personal `~/.ssh/config` file and the system-wide `/etc/ssh/ssh_config` file. This precedence means that you can temporarily adjust host key checking behavior for a single connection without altering your permanent configuration.

For example, to connect to a new host and to automatically accept its host key (which is generally discouraged for security reasons unless you are certain of the host's authenticity), you could use the following command:

```bash
ssh -o StrictHostKeyChecking=accept-new hostb
```

## Verifying SSH Host Key Fingerprints

To ensure the authenticity of a target SSH server and to protect against interceptor attacks, the client must verify the host's public key. However, SSH public keys are long, complex strings of characters that are typically Base64-encoded. Trying to manually compare or verify a key against a trusted source is error-prone and impractical.

An SSH host key fingerprint is a short, cryptographic hash of the server's public key that enables the SSH client (and user) to confirm that they are connecting to the intended, legitimate server and not to an imposter. Fingerprints are easier for a human to visually inspect and compare.

An SSH host key fingerprint is a short, cryptographic hash of the server's public key that enables the SSH client (and user) to confirm that they are connecting to the intended, legitimate server and not to an imposter. Fingerprints are easier for a human to visually inspect and compare.

On the SSH server, use the `ssh-keygen` command to display its public key fingerprint:

```bash
ssh-keygen -l -f /etc/ssh/ssh_host_ed25519_key.pub
```

You might have to adjust the path to the public key file if your server uses a different algorithm such as RSA or ECDSA.

After you verify the server's public key fingerprint, you must securely communicate this fingerprint to the client-side administrator by using a trusted alternative communication method, such as a phone call or video conference.

The client-side administrator must compare this received fingerprint with the one that the ssh command presents when they first attempt to connect. If the fingerprints match, then the server's identity is confirmed and the connection can proceed. If the fingerprints do not match, then the connection should be stopped because of a potential security risk.

In the following example, the user must carefully compare the fingerprint of the SSH server with a trusted source, before typing yes to proceed with the connection.

```bash
user@host:~$ ssh hostb
The authenticity of host 'hostb (192.168.250.11)' can't be established.
ED25519 key fingerprint is SHA256:Qit7NeebQCgP2otXSaVXbw1rGmUVMlybXyV68qaND/M.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added 'hostb' (ED25519) to the list of known hosts.
user@hostb's password: password
...output omitted...
```

## Regenerating SSH Host Keys on Servers

You might want to regenerate SSH host keys for security reasons, such as if you suspect that a key is compromised or if you are creating a new server image and need unique identifiers for each instance

Starting in Red Hat Enterprise Linux 10, the SSH server by default uses three pairs of keys and the ED25519, ECDSA, and RSA host key algorithms. These host key files are in the `/etc/ssh/` directory on the server:

```bash
ls -l /etc/ssh/ssh_host_*
```

If you need to generate new SSH host key pairs, then delete the existing key pairs and restart the SSH daemon. The `sshd.service` unit automatically detects the absence of these keys during service start and regenerates all three key pairs.

```bash
rm -f /etc/ssh/ssh_host_*
systemctl restart sshd.service
```

**Note**

    On systems that use the Cloud-init package, Cloud-init is typically responsible for managing SSH host key generation as part of its instance provisioning process. As a result, SSH host key pairs might not regenerate automatically, or Cloud-init might overwrite any manually generated keys during subsequent provisioning steps.

## Managing Known Host Files on Clients

After regenerating host keys, for any SSH client that previously connected to your server, the earlier host key is still stored in its known_hosts file. When these clients attempt to connect again, they receive a warning about a potential interceptor attack because the server's identity no longer matches what the client expects.

```bash
user@host:~$ ssh user@hostb
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ED25519 key sent by the remote host is
SHA256:0sQuJcXztSoxwi+2hNrj6iRYQpjq2kXSCzcZA8m5Izs.
Please contact your system administrator.
Add correct host key in /home/user/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /home/user/.ssh/known_hosts:3
Host key for hostb has changed and you have requested strict checking.
Host key verification failed.
user@host:~$
```

SSH clients keep a list of known remote systems and their corresponding host keys in one of two locations:

- The `/etc/ssh/ssh_known_hosts` file

    This system-wide file is not present by default; a system administrator must create it and add trusted host keys to it. It stores public keys for hosts that are known to the entire system, which means that it benefits all users on the system. By prepopulating this file, administrators help users to avoid the dilemma of trusting a new, unknown host key, which is especially beneficial in large environments.

- The `~/.ssh/known_hosts` file
    This user-specific file is in the home directory of each user. If the SSH client does not find a remote system's public key in the system-wide known hosts file, then it then looks for the key in the user's file. By default, SSH automatically adds a server's host key to this file the first time that a user connects and accepts it. Users can, however, configure their SSH client to prevent this automatic addition.

If a remote server's host key changes, then you can remove the outdated entry from your `~/.ssh/known_hosts` file. You can update this file by using a text editor to delete the line that corresponds to the changed host, or by using the `ssh_keygen` utility, which is the safer option.

For example, to remove a key entry for hostb, you can run the command with the -R option:

```bash
ssh-keygen -R hostb
```

If the offending key is present in the system-wide known hosts file, then the administrator must delete the matching entry:

```bash
ssh-keygen -R hostb -f /etc/ssh/ssh_known_hosts
```

The previous command identified three matching key entries for the host and deleted the lines.

## Populating Known Host Files

The `ssh-keyscan` command is a valuable tool for collecting the public host keys of remote servers. You can use this command to manually populate `known_hosts` files, which is particularly useful for scripting, automation, or setting up a system-wide `ssh_known_hosts` file.

To retrieve and save the public key of a remote host, append the output of the `ssh-keyscan` command to your personal known hosts file:

```bash
ssh-keyscan hostb >> ~/.ssh/known_hosts
```

Be default, the command saves all key pairs that the server might have presented. You can verify the fingerprint of your stored host keys by using the `ssh-keygen` command:

```bash
ssh-keygen -l -f ~/.ssh/known_hosts
```

You can also open the known hosts file in a text editor to view complete public keys instead of just their fingerprints.

A system administrator might use the `ssh-keyscan` command to add a new host to the system-wide known hosts file. The following command demonstrates that the tool can also operate in quiet mode (-q) and collect specific types (-t) of host keys:

```bash
ssh-keyscan -q -t ed25519 hostb >> /etc/ssh/ssh_known_hosts
```

Another valid scenario is for the system administrator to use the `ssh-keyscan` command to scan an entire network segment for host keys. This approach can be useful for quickly gathering keys from a range of servers in a controlled environment

For example, you can scan a range of IP addresses to collect RSA host keys:

```bash
ssh-keyscan -q -t rsa 172.25.250.0/24 >> /etc/ssh/ssh_known_hosts
```

**Warning**

    Although the ssh-keyscan command is convenient, you must exercise caution, especially when scanning an entire network. When using the ssh-keyscan command, you are trusting the key that is presented by the remote server at that moment. On an untrusted network, where a server's identity might be spoofed, you should verify the retrieved key's fingerprint through an alternative method before adding it to your known_hosts file. Directly appending the ssh-keyscan command output to a known_hosts file without verification can expose you to interceptor attacks.


