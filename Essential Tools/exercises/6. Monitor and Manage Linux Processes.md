✅ **Task 1:** 

Create the task101.sh script in the /home/student/bin directory. The task101.sh script generates artificial CPU load by performing arithmetic operations endlessly.

**Script**
```bash
#!/bin/bash
touch ~/bin/.$(basename $0)
while true; do
  var=1
  while [[ var -lt 50000 ]]; do
    var=$(($var+1))
  done
  sleep 1
done
```



```bash
mkdir /home/student/bin
```
```bash
cat << 'EOF' >> /home/student/bin/task101.sh
#!/bin/bash
touch ~/bin/.$(basename $0)
while true; do
  var=1
  while [[ var -lt 50000 ]]; do
    var=$(($var+1))
  done
  sleep 1
done
EOF
```
```bash
chmod a+x /home/student/bin/task101.sh
/home/student/bin/task101.sh &
jobs
```
✅ **Task 2:** 
In the right terminal, monitor all processes that are running in the serverb machine.

```bash
ssh student@serverb
top
```


✅ **Task 3:**
In the left terminal shell, verify the number of logical CPUs on the virtual machine. Run the task101.sh script in the background.


```bash
grep "model name" /proc/cpuinfo | wc -l
/home/student/bin/task101.sh &
```

✅ **Task 4:** 
In the right terminal shell, observe running processes. Find the process ID (PID) of the task101.sh process and the amount of CPU that the process consumes.

Examine the consumption of system load, threads, and memory. Make sure to find the system resources that the task101.sh process impacts.

```bash
# PID
ps aux |grep task101.sh |awk '{print $2}' | head -n 1

# CPU 
ps aux |grep task101.sh | awk '{print $3}' | head -n 1
top -H -p $(ps aux |grep task101.sh |awk '{print $2}' | head -n 1)
```

✅ **Task 5:**
Copy the task101.sh script to a new task102.sh file, and increase the artificial CPU load to 100000 in the new script. Start the task102.sh process in the background.

```bash
cp /home/student/bin/task101.sh /home/student/bin/task102.sh
sed -i 's/50000/100000/g' /home/student/bin/task102.sh
grep -n 100000 /home/student/bin/task102.sh
/home/student/bin/task102.sh &
jobs
top -H -p $(ps aux |grep task101.sh |awk '{print $2}' | head -n 1) 
# top -H -p $(ps j |grep task102.sh | head -n 1 | awk '{print $2}')
```
✅ **Task 6:**

In the right terminal shell, verify that the task102.sh process is running and uses the most CPU resources. Examine the load average of the serverb machine.

```bash
ssh studen@serverb
top -o %CPU
ps -eo pid,comm,%cpu,%mem --sort=-%cpu | head
uptime
```
✅ **Task 7:**

Copy the task101.sh script to a new script named task103.sh. Increase the addition count to 800000. Start task103.sh in the background.

Monitor the serverb machine load average. The load average might take a few minutes to increase.

```bash
cp /home/student/bin/task101.sh /home/student/bin/task103.sh
sed -i 's/50000/800000/' /home/student/bin/task103.sh
grep -n 800000 /home/student/bin/task103.sh
/home/student/bin/task103.sh &
jobs
top -o %CPU
```

✅ **Task 8:**

In the left terminal shell, switch to the root user and use redhat as the password. Suspend the task101.sh process. List the remaining jobs. Verify that the task101.sh process is now in the T state.

solution #1
```bash
sudo -i
ps aux | grep task101.sh | grep student | awk '{print $2}'
kill -l
kill -SIGSTOP $(ps aux | grep task101.sh | grep student | awk '{print $2}')
ps aux | grep task101.sh | grep student | awk '{print $8}' #T
```
solution #2
```bash
sudo -i
pgrep -l -u student
kill -l
pkill -SIGSTOP task101.sh
ps jT
```

✅ **Task 9:**

Resume the task101.sh process.

```bash
kill -l
pkill -SIGCONT task101.sh
ps aux | grep task101
```


✅ **Task 10:**

Terminate the task101.sh, task102.sh, and task103.sh processes from the command line. After terminating these processes, examine the CPU usage and load average.

```bash
pkill task101.sh
pkill task102.sh
pkill task103.sh
top
```