# Scheduling a Future User Job
---

## Deferred User Tasks

Sometimes you might need to run one or more commands at a specific future time. An example is a user who schedules a long-running maintenance task to occur in the middle of the night. Another example is a system administrator who is working on a firewall configuration and queues a safety job to reset the firewall settings to a former working state in ten minutes' time. The system administrator then deactivates the job before it runs, unless the new firewall configuration worked.

These scheduled commands are known as tasks or jobs, and the deferred term indicates that these tasks run in the future.

One solution for Red Hat Enterprise Linux users to schedule deferred tasks is the at command, which is installed and enabled by default. The at package provides the atd system daemon and the at and atq commands to interact with the daemon.

Any user can queue jobs for the atd daemon by using the at command. The atd daemon provides queues from a to z and from A to Z. The queue with highest letters run with high priority.

## Schedule Deferred User Tasks

Use the `at TIMESPEC` command to start entering a new job to schedule. The at command reads from STDIN (standard input, for example your keyboard) to obtain the commands to run. When manually entering commands, complete the input by pressing Ctrl+D on an empty line. You can use input redirection from a script file for entering more complex commands.

```bash
at now +5min < myfile
```
```bash
warning: commands will be executed using /bin/sh
job 2 at Wed May 14 20:40:00 2025
```

The `at` command TIMESPEC argument accepts natural time specifications for when to run a job. For example, specify a time as 02:00pm, 15:59, midnight, or even teatime, followed by an optional date or number of days in the future.

The TIMESPEC argument expects time and date specifications in that order. If you provide the date and not the time, then the time defaults to the current time. If you provide the time and not the date, then the date is considered to be matched, and the jobs run when the time next matches.

The following example shows a job schedule without providing the date. The at command schedules the job for today or tomorrow depending whether the time has passed.

```bash
at 21:03 < myfile
```
```bash
warning: commands will be executed using /bin/sh
job 3 at Fri August 22 21:03:00 2025
```
The at command schedules the job for tomorrow when the time is reached.

```bash
at 21:00 < myfile
```
```bash
warning: commands will be executed using /bin/sh
job 4 at Sat May 23 21:00:00 2025
```

The man pages for the at command and other documentation sources use lowercase to write the natural time specifications. You can use lowercase, sentence case, or uppercase.

Here are examples of time specifications that you can use:

- now +5min
- teatime tomorrow (teatime is 16:00)
- noon +4 days
- 5 pm august 3 2025

For other valid time specifications, refer to the local timespec document in the references.

View the commands in the pending job number 3. 

```bash
at -c 3
```

# Inspect and Manage Deferred User Jobs

For an overview of the pending jobs for the current user, use the `atq` or the `at -l` command.

```bash
atq
```

```bash
28  Mon May 19 05:13:00 2025 a user
29  Tue May 20 16:00:00 2025 h user
30  Wed May 21 12:00:00 2025 a user
```

In the preceding output, every line represents a different scheduled future job. The following description applies to the first line of the output:

- `28` is the unique job number.
- `Mon` May 16 05:13:00 2022 is the execution date and time for the scheduled job.
- `a` indicates that the job is scheduled with the default queue a.
- `user` is the owner and user for the job.

Important

    Unprivileged users can view and manage only their own jobs. The root user can view and manage all jobs for all users.

Use the `at -c JOBNUMBER` command to inspect the commands that run when the atd daemon executes a job. This command shows the job's environment, which is set from the user's environment when they created the job, and the command syntax to run.

## Remove Jobs from a Schedule

The `atrm JOBNUMBER` command removes a scheduled job. Remove a scheduled job when you no longer need it, for example, when a remote firewall configuration succeeded and you do not need to reset it.

```bash
atrm 2
```

---
# Recurring User Jobs
---

Recurring jobs run repeatedly on a schedule. Red Hat Enterprise Linux provides the crond daemon, which is enabled and started by default.

The `crond` daemon reads multiple configuration files: one per user, and a set of system-wide files. Each user has a personal file that they edit with the `crontab` command `-e` option.

When executing recurring jobs, these configuration files provide detailed control to users and administrators. If the scheduled job is not written to use redirection, then the crond daemon emails any generated output or errors to the job owner.

## Schedule Recurring User Jobs

Use the `crontab` command to manage scheduled jobs. The following list shows the commands that a user can use to manage their jobs:

**Examples of the crontab Command**

| Command          | Intended use                                                                                   |
| ---------------- | ----------------------------------------------------------------------------------------------- |
| `crontab -l`     | List the jobs for the current user.                                                             |
| `crontab -r`     | Remove all jobs for the current user.                                                           |
| `crontab -e`     | Edit jobs for the current user.                                                                 |
| `crontab filename` | Remove all jobs, and replace them with jobs that are read from the filename file. This command uses stdin input when no file is specified. |

A privileged user might use the `crontab` command `-u` option to manage jobs for another user. The crontab command is never used to manage system jobs, and using the `crontab` command as the `root` user is not recommended due to the ability to exploit personal jobs that are configured to run as the `root` user.

## User Job Format

The `crontab` comamnd `-e` option invokes the vim editor by default unless the EDITOR environment variable is set for another editor. Each job must use a unique line in the crontab file. Follow these recommendations for valid entries when writing recurring jobs:

- Empty lines for ease of reading
- Comments on lines that start with the number sign (#)
- Environment variables with a NAME=value format, which affects all lines after the line where they are declared

Standard variable settings include the SHELL variable, to declare the shell that interprets the remaining lines of the `crontab` file. The MAILTO variable determines who should receive the emailed output.

Note

    The ability to send an email requires additional system configuration for a local mail server or an SMTP relay.

The fields in the crontab file appear in the following order:

- Minutes
- Hours
- Day of month
- Month
- Day of week
- Command

The command executes when the Day of month or Day of week fields use the same value other than the * character. For example, to run a command on the 11th day of every month, and every Friday at 12:15 (24-hour format), use the following job format:

```bash
15 12 11 * Fri command
```

The first five fields all use the same syntax rules:

- Use the `*` character to execute in every possible instance of the field.
- A number to specify the number of minutes or hours, a date, or a day of the week. For days of the week, 0 equals Sunday, 1 equals Monday, 2 equals Tuesday, and so on, and 7 also equals Sunday.
- Use x-y for a range, which includes the x and y values.
- Use x,y for lists. Lists might include ranges as well, for example, 5,10-13,17 in the Minutes column, for a job to run at 5, 10, 11, 12, 13, and 17 minutes past the hour.
- The `*/x` indicates an interval of x; for example, */7 in the Minutes column runs a job every seven minutes.

Additionally, 3-letter English abbreviations are used for months or days of the week, for example, Jan, Feb, and Mon, Tue.

The last field contains the full command with options and arguments to execute with the default shell. If the command contains an unescaped percentage sign (%), then that percentage sign is treated as a newline character, and everything after the percentage sign passes to the command as stdin input.

**Important**

    When specifying a range, the first number must be less than or equal to the second one. This applies to a number's matching English abbreviation as well.

    For example, the range Tue-Fri (numerically expressed as 2-5) is valid, however the range Fri-Tue (numerically written as 5-2) is not valid because the first number 5 is greater than the second number 2. The second range can be correctly expressed as a list of two ranges: Sun-Tue,Fri-Sat (numerically expressed as 0-2,5-6).

## Examples of Recurring User Jobs

The following job executes the `/usr/local/bin/yearly_backup` command at 09:00:00 on 3 February, every year. February is represented as the number 2 in the example, because it is the second month of the year.

```bash
0 9 3 2 * /usr/local/bin/yearly_backup
```

The following job sends an email that contains the Chime word to the owner of this job at every fifth minute past every hour from 09:00 through 16:59 on Fridays in July.

```bash
*/5 9-16 * Jul 5 echo "Chime"
```

The preceding 9-16 range of hours means that the job timer starts at 09:00 and continues until 16:59. The job starts executing at 09:00 with the last execution at 16:55, because five minutes after 16:55 is 17:00, which is beyond the given scope of hours.

If a range is specified for the hours instead of a single value, then all hours within the range might match. Therefore, with the hours of 9-16, this example matches every five minutes from 09:00 through 16:55.

The following job runs the /usr/local/bin/daily_report command every day from Monday to Friday at two minutes before midnight.

```bash
58 23 * * 1-5 /usr/local/bin/daily_report
```

The following job executes the mutt command to send the Checking in mail message to the developer@example.com recipient every day from Monday to Friday at 09:00.

```bash
0 9 * * 1-5 mutt -s "Checking in" developer@example.com % Hi there, just checking in.
```
