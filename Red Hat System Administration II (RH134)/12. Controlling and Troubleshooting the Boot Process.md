# Managing the Boot Loader and Kernel Command Line
---

## The Boot Loader

Modern computer systems are complex combinations of hardware and software. Starting from an undefined, powered-down state to a running system with a login prompt requires many pieces of hardware and software to work together.

When a computer is powered on, it loads a firmware boot system from a ROM chip on the motherboard. In modern x86 machines, this firmware boot system is typically either Unified Extensible Firmware Interface (UEFI) or Basic Input/Output System (BIOS). BIOS was more common in machines manufactured before 2020, and UEFI is the most common system present in current motherboards.

The job of the firmware boot system is to load a boot loader from a disk and to pass the control of the boot process to the boot loader. Boot loaders are programs designed to interface with the firmware boot system, set the system for boot, and then start the kernel to continue the system initialization. The default boot loader for Red Hat Enterprise Linux 10 is the GRand Unified Bootloader version 2 (GRUB2).

## GRUB2 with UEFI

In a UEFI system, the boot firmware reads settings from nonvolatile RAM (NVRAM) to determine which disk and Extensible Firmware Interface (EFI) application to load. The disk typically contains an EFI system partition, which is usually mounted on the /boot/efi directory. GRUB2 generates files that the UEFI system can load. After the GRUB2 boot-loader EFI application has been loaded, the system moves to the next boot stage.

## GRUB2 with BIOS

In a BIOS system, the boot firmware reads a specially formatted boot sector on a disk for the `boot.img` boot-loader image. This boot-loader image loads the `core.img` image from the unpartitioned MBR space before the first partition. The `core.img` image loads extra modules that can initialize file systems, and the system moves to the next boot stage. GRUB2 generates and installs these images into the MBR space on the disk.

## Further Boot Stages

After GRUB2 has fully initialized and loaded disks, it presents a boot menu to the user.

![alt text](images/image9.png)

From this boot menu, you can select which preconfigured kernel to boot, as well as apply any kernel arguments to boot. The Linux kernel package typically generates these boot-menu entries when you install a new version.

To modify a boot entry from the GRUB2 menu, you can use the built-in editor. You can access the editor in GRUB2 by pressing E.

![alt text](images/image10.png)

The changes made within the GRUB2 editor apply to only that boot instance. To make any changes persistent in future boot instances, you can make those changes by using the `grubby` command.

## Controlling GRUB2 from a Booted System

You can modify the default configuration of GRUB2 by using the `grubby` command. You can use the `grubby` command to perform various tasks, such as adding or removing kernel arguments, changing the default boot-menu entry, and viewing information about existing boot-menu entries.

To view information about an existing entry, you can use the `grubby` command `--info` option.

```bash
grubby --info 1
```
```bash
index=1 #1
kernel="/boot/vmlinuz-6.12.0-55.12.1.el10_0.x86_64" #2
args="console=tty0 ... crashkernel=2G-64G:256M,64G-:512M $tuned_params" #3
root="UUID=15507695-22bb-4c65-94e6-a438e095983f" #4
initrd="/boot/initramfs-6.12.0-55.12.1.el10_0.x86_64.img $tuned_initrd" #5
title="Red Hat Enterprise Linux (6.12.0-55.12.1.el10_0.x86_64) 10.0 (Coughlan)" #6
id="b70d796f931842cb9776f658cd068435-6.12.0-55.12.1.el10_0.x86_64" #7
```

`1` The index value is the entry number for the boot-menu list, starting at 0.

`2` The kernel value is the path to the Linux kernel that GRUB2 loads.

`3` The args value is a list of kernel arguments that are passed to the Linux kernel.

`4` The root value is the block device that the kernel and the initramfs image exist on.

`5` The initrd value is the path to the initial RAM file system image, which the early stages of Linux boot within.

`6` The title value is the name that is shown for the boot entry in the GRUB2 boot menu.

`7` The id value is a unique identifier for this boot entry.


To change the default boot entry, so that GRUB2 automatically chooses it on boot, you can use the `grubby` command `--set-default-index` option.

```bash
grubby --set-default-index 0
```
```bash
The default is /boot/loader/entries/ffffffffffffffffffffffffffffffff-6.12.0-55.9.1.el10_0.x86_64.conf with index 0 and kernel /boot/vmlinuz-6.12.0-55.9.1.el10_0.x86_64
```

## Kernel Command-line Arguments

You can pass various arguments to the Linux kernel to configure the system at boot. In some cases, a command-line argument is the only way to change a configuration, such as defining how the kernel behaves if it crashes. The available kernel command-line arguments and exact behavior depend on the version of the Linux kernel that you have installed.

To add a command-line argument, or make other changes related to the kernel, you can use the `grubby` command `--update-kernel` option.

The following example adds the `rhgb quiet` command-line argument to suppress kernel boot messages by using the `--args` option:

```bash
grubby --update-kernel /boot/vmlinuz-6.12.0-55.9.1.el10_0.x86_64 \
--args="rhgb quiet"
```

To remove the command-line argument, add the `rhgb` quiet argument by using the `--remove-args` option:

```bash
grubby --update-kernel /boot/vmlinuz-6.12.0-55.9.1.el10_0.x86_64 \
--remove-args="rhgb quiet"
```
---
# Exploring the Boot Process and Selecting a Boot Target
---

## System Initialization in Red Hat Enterprise Linux 10

After the system is powered on, and the boot loader is started, the system initialization process begins.

The following list gives a high-level overview of the system initialization process in Red Hat Enterprise Linux 10.

- The boot loader loads the kernel and the `initramfs` image from disk and places them in memory. The `initramfs` image is an archive with the kernel modules for all the required hardware at boot, initialization scripts, and more. In RHEL 10, the `initramfs` image contains a bootable root file system with a running kernel and a systemd unit. You can use the `lsinitrd` command to inspect the `initramfs` image and to extract its contents.

- The boot loader passes control to the kernel, along with any specified options on the kernel command line, and the location of the initramfs image in memory.

- The kernel initializes all hardware for which it can find a driver in the `initramfs` image, and then executes the `/sbin/init` script from the `initramfs` image as PID 1. You can override this script by using the `init=` kernel parameter. In RHEL 10, the `/sbin/init` script is a symbolic link to the systemd unit.

- The boot loader passes control to the kernel, along with any specified options on the kernel command line, and the location of the `initramfs` image in memory.

- The kernel initializes all hardware for which it can find a driver in the `initramfs` image, and then executes the `/sbin/init` script from the `initramfs` image as PID 1. You can override this script by using the `init=` kernel parameter. In RHEL 10, the `/sbin/init` script is a symbolic link to the systemd unit.

- The `systemd` unit from the `initramfs` image executes all units for the `initrd.target` target. This unit includes mounting the root file system on the `/sysroot` directory, which is listed in the `/etc/fstab` file on the disk.

- The kernel switches (pivots) the root file system from the `initramfs` image to the root file system in the `/sysroot` directory. The `systemd` unit then re-executes itself by using the installed copy of the `systemd` unit on the disk.

- Then, the `systemd` unit is in full control of the boot process. The `systemd` unit looks for a default target, which is either configured on the system or is passed from the kernel command line. The systemd unit then starts (and stops) units to comply with the configuration for that target, and automatically resolves dependencies between units.

- These targets typically start a text-based login or a graphical login screen, thus completing the boot process.

## Selecting a systemd Target

A `systemd` target is a set of `systemd` units that the system must start to reach an intended state.

The following table lists the most important targets.

| Target              | Purpose                                                                                      |
| ------------------- | -------------------------------------------------------------------------------------------- |
| `graphical.target`  | Supports multiple users and provides graphical (GUI) **and** text-based logins.              |
| `multi-user.target` | Supports multiple users and provides text-based logins only (no graphical session).          |
| `rescue.target`     | Provides a single-user system to enable repairing the system (similar to runlevel 1).        |
| `emergency.target`  | Starts the most minimal system for repairing the system when `rescue.target` fails to start. |

A target can be a part of another target. For example, the `graphical.target` unit includes the `multi-user.target` unit, which depends on the `basic.target` unit and others.

You can view these dependencies with the following command:

```bash
systemctl list-dependencies graphical.target | grep target
```
```bash
graphical.target
* └─multi-user.target
*   ├─basic.target
*   │ ├─paths.target
*   │ ├─slices.target
*   │ ├─sockets.target
*   │ ├─sysinit.target
*   │ │ ├─cryptsetup.target
*   | | ├─integritysetup.target
*   │ │ ├─local-fs.target
...output omitted...
```

To list the available targets, use the following command:

```bash
systemctl list-units --type=target --all
```
```bash
 UNIT                      LOAD      ACTIVE   SUB    DESCRIPTION
  ---------------------------------------------------------------------------
  basic.target              loaded    active   active Basic System
...output omitted...
  cloud-config.target       loaded    active   active Cloud-config availability
  cloud-init.target         loaded    active   active Cloud-init target
  cryptsetup-pre.target     loaded    inactive dead   Local Encrypted Volumes (Pre)
  cryptsetup.target         loaded    active   active Local Encrypted Volumes
...output omitted...
```
## Select a Target at Runtime

On a running system, administrators can switch to a different target by using the `systemctl isolate` command.

```bash
systemctl isolate multi-user.target
```

Isolating a target stops all services that the target does not require (and its dependencies), and starts any required services that are not yet started.

Not all targets can be isolated. You can isolate only targets where the AllowIsolate=yes option is set in their unit files.

For example, you can isolate the graphical target:

```bash
systemctl cat graphical.target
```

```bash
# /usr/lib/systemd/system/graphical.target
...output omitted...
[Unit]
Description=Graphical Interface
Documentation=man:systemd.special(7)
Requires=multi-user.target
Wants=display-manager.service
Conflicts=rescue.service rescue.target
After=multi-user.target rescue.service rescue.target display-manager.service
AllowIsolate=yes
```

But you cannot isolate the `cryptsetup` target

```bash
systemctl cat cryptsetup.target
```
```bash
# /usr/lib/systemd/system/cryptsetup.target
...output omitted...
[Unit]
Description=Local Encrypted Volumes
Documentation=man:systemd.special(7)
```

