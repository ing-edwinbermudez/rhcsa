# Managing the Boot Loader and Kernel Command Line
---

## The Boot Loader

Modern computer systems are complex combinations of hardware and software. Starting from an undefined, powered-down state to a running system with a login prompt requires many pieces of hardware and software to work together.

When a computer is powered on, it loads a firmware boot system from a ROM chip on the motherboard. In modern x86 machines, this firmware boot system is typically either Unified Extensible Firmware Interface (UEFI) or Basic Input/Output System (BIOS). BIOS was more common in machines manufactured before 2020, and UEFI is the most common system present in current motherboards.

The job of the firmware boot system is to load a boot loader from a disk and to pass the control of the boot process to the boot loader. Boot loaders are programs designed to interface with the firmware boot system, set the system for boot, and then start the kernel to continue the system initialization. The default boot loader for Red Hat Enterprise Linux 10 is the GRand Unified Bootloader version 2 (GRUB2).

## GRUB2 with UEFI

In a UEFI system, the boot firmware reads settings from nonvolatile RAM (NVRAM) to determine which disk and Extensible Firmware Interface (EFI) application to load. The disk typically contains an EFI system partition, which is usually mounted on the /boot/efi directory. GRUB2 generates files that the UEFI system can load. After the GRUB2 boot-loader EFI application has been loaded, the system moves to the next boot stage.

## GRUB2 with BIOS

In a BIOS system, the boot firmware reads a specially formatted boot sector on a disk for the `boot.img` boot-loader image. This boot-loader image loads the `core.img` image from the unpartitioned MBR space before the first partition. The `core.img` image loads extra modules that can initialize file systems, and the system moves to the next boot stage. GRUB2 generates and installs these images into the MBR space on the disk.

## Further Boot Stages

After GRUB2 has fully initialized and loaded disks, it presents a boot menu to the user.

![alt text](images/image9.png)

From this boot menu, you can select which preconfigured kernel to boot, as well as apply any kernel arguments to boot. The Linux kernel package typically generates these boot-menu entries when you install a new version.

To modify a boot entry from the GRUB2 menu, you can use the built-in editor. You can access the editor in GRUB2 by pressing E.

![alt text](images/image10.png)

The changes made within the GRUB2 editor apply to only that boot instance. To make any changes persistent in future boot instances, you can make those changes by using the `grubby` command.

## Controlling GRUB2 from a Booted System

You can modify the default configuration of GRUB2 by using the `grubby` command. You can use the `grubby` command to perform various tasks, such as adding or removing kernel arguments, changing the default boot-menu entry, and viewing information about existing boot-menu entries.

To view information about an existing entry, you can use the `grubby` command `--info` option.

```bash
grubby --info 1
```
```bash
index=1 #1
kernel="/boot/vmlinuz-6.12.0-55.12.1.el10_0.x86_64" #2
args="console=tty0 ... crashkernel=2G-64G:256M,64G-:512M $tuned_params" #3
root="UUID=15507695-22bb-4c65-94e6-a438e095983f" #4
initrd="/boot/initramfs-6.12.0-55.12.1.el10_0.x86_64.img $tuned_initrd" #5
title="Red Hat Enterprise Linux (6.12.0-55.12.1.el10_0.x86_64) 10.0 (Coughlan)" #6
id="b70d796f931842cb9776f658cd068435-6.12.0-55.12.1.el10_0.x86_64" #7
```

`1` The index value is the entry number for the boot-menu list, starting at 0.

`2` The kernel value is the path to the Linux kernel that GRUB2 loads.

`3` The args value is a list of kernel arguments that are passed to the Linux kernel.

`4` The root value is the block device that the kernel and the initramfs image exist on.

`5` The initrd value is the path to the initial RAM file system image, which the early stages of Linux boot within.

`6` The title value is the name that is shown for the boot entry in the GRUB2 boot menu.

`7` The id value is a unique identifier for this boot entry.


To change the default boot entry, so that GRUB2 automatically chooses it on boot, you can use the `grubby` command `--set-default-index` option.

```bash
grubby --set-default-index 0
```
```bash
The default is /boot/loader/entries/ffffffffffffffffffffffffffffffff-6.12.0-55.9.1.el10_0.x86_64.conf with index 0 and kernel /boot/vmlinuz-6.12.0-55.9.1.el10_0.x86_64
```

## Kernel Command-line Arguments

You can pass various arguments to the Linux kernel to configure the system at boot. In some cases, a command-line argument is the only way to change a configuration, such as defining how the kernel behaves if it crashes. The available kernel command-line arguments and exact behavior depend on the version of the Linux kernel that you have installed.

To add a command-line argument, or make other changes related to the kernel, you can use the `grubby` command `--update-kernel` option.

The following example adds the `rhgb quiet` command-line argument to suppress kernel boot messages by using the `--args` option:

```bash
grubby --update-kernel /boot/vmlinuz-6.12.0-55.9.1.el10_0.x86_64 \
--args="rhgb quiet"
```

To remove the command-line argument, add the `rhgb` quiet argument by using the `--remove-args` option:

```bash
grubby --update-kernel /boot/vmlinuz-6.12.0-55.9.1.el10_0.x86_64 \
--remove-args="rhgb quiet"
```
---
# Exploring the Boot Process and Selecting a Boot Target
---

## System Initialization in Red Hat Enterprise Linux 10

After the system is powered on, and the boot loader is started, the system initialization process begins.

The following list gives a high-level overview of the system initialization process in Red Hat Enterprise Linux 10.

- The boot loader loads the kernel and the `initramfs` image from disk and places them in memory. The `initramfs` image is an archive with the kernel modules for all the required hardware at boot, initialization scripts, and more. In RHEL 10, the `initramfs` image contains a bootable root file system with a running kernel and a systemd unit. You can use the `lsinitrd` command to inspect the `initramfs` image and to extract its contents.

- The boot loader passes control to the kernel, along with any specified options on the kernel command line, and the location of the initramfs image in memory.

- The kernel initializes all hardware for which it can find a driver in the `initramfs` image, and then executes the `/sbin/init` script from the `initramfs` image as PID 1. You can override this script by using the `init=` kernel parameter. In RHEL 10, the `/sbin/init` script is a symbolic link to the systemd unit.

- The boot loader passes control to the kernel, along with any specified options on the kernel command line, and the location of the `initramfs` image in memory.

- The kernel initializes all hardware for which it can find a driver in the `initramfs` image, and then executes the `/sbin/init` script from the `initramfs` image as PID 1. You can override this script by using the `init=` kernel parameter. In RHEL 10, the `/sbin/init` script is a symbolic link to the systemd unit.

- The `systemd` unit from the `initramfs` image executes all units for the `initrd.target` target. This unit includes mounting the root file system on the `/sysroot` directory, which is listed in the `/etc/fstab` file on the disk.

- The kernel switches (pivots) the root file system from the `initramfs` image to the root file system in the `/sysroot` directory. The `systemd` unit then re-executes itself by using the installed copy of the `systemd` unit on the disk.

- Then, the `systemd` unit is in full control of the boot process. The `systemd` unit looks for a default target, which is either configured on the system or is passed from the kernel command line. The systemd unit then starts (and stops) units to comply with the configuration for that target, and automatically resolves dependencies between units.

- These targets typically start a text-based login or a graphical login screen, thus completing the boot process.

## Selecting a systemd Target

A `systemd` target is a set of `systemd` units that the system must start to reach an intended state.

The following table lists the most important targets.

| Target              | Purpose                                                                                      |
| ------------------- | -------------------------------------------------------------------------------------------- |
| `graphical.target`  | Supports multiple users and provides graphical (GUI) **and** text-based logins.              |
| `multi-user.target` | Supports multiple users and provides text-based logins only (no graphical session).          |
| `rescue.target`     | Provides a single-user system to enable repairing the system (similar to runlevel 1).        |
| `emergency.target`  | Starts the most minimal system for repairing the system when `rescue.target` fails to start. |

A target can be a part of another target. For example, the `graphical.target` unit includes the `multi-user.target` unit, which depends on the `basic.target` unit and others.

You can view these dependencies with the following command:

```bash
systemctl list-dependencies graphical.target | grep target
```
```bash
graphical.target
* └─multi-user.target
*   ├─basic.target
*   │ ├─paths.target
*   │ ├─slices.target
*   │ ├─sockets.target
*   │ ├─sysinit.target
*   │ │ ├─cryptsetup.target
*   | | ├─integritysetup.target
*   │ │ ├─local-fs.target
...output omitted...
```

To list the available targets, use the following command:

```bash
systemctl list-units --type=target --all
```
```bash
 UNIT                      LOAD      ACTIVE   SUB    DESCRIPTION
  ---------------------------------------------------------------------------
  basic.target              loaded    active   active Basic System
...output omitted...
  cloud-config.target       loaded    active   active Cloud-config availability
  cloud-init.target         loaded    active   active Cloud-init target
  cryptsetup-pre.target     loaded    inactive dead   Local Encrypted Volumes (Pre)
  cryptsetup.target         loaded    active   active Local Encrypted Volumes
...output omitted...
```
## Select a Target at Runtime

On a running system, administrators can switch to a different target by using the `systemctl isolate` command.

```bash
systemctl isolate multi-user.target
```

Isolating a target stops all services that the target does not require (and its dependencies), and starts any required services that are not yet started.

Not all targets can be isolated. You can isolate only targets where the AllowIsolate=yes option is set in their unit files.

For example, you can isolate the graphical target:

```bash
systemctl cat graphical.target
```

```bash
# /usr/lib/systemd/system/graphical.target
...output omitted...
[Unit]
Description=Graphical Interface
Documentation=man:systemd.special(7)
Requires=multi-user.target
Wants=display-manager.service
Conflicts=rescue.service rescue.target
After=multi-user.target rescue.service rescue.target display-manager.service
AllowIsolate=yes
```

But you cannot isolate the `cryptsetup` target

```bash
systemctl cat cryptsetup.target
```
```bash
# /usr/lib/systemd/system/cryptsetup.target
...output omitted...
[Unit]
Description=Local Encrypted Volumes
Documentation=man:systemd.special(7)
```


## Set a Default Target

When the system starts, the systemd unit activates the default.target target. Typically, the default.target file in the `/etc/systemd/system` directory is a symbolic link to either the graphical.target or the `multi-user.target` targets.

Instead of editing this symbolic link manually, the systemctl command provides two subcommands to manage this link: `get-default` and `set-default`.

Use the `systemctl` command to get the default target:

```bash
systemctl get-default
```
```bash
multi-user.target
```
Use the systemctl command to set graphical.target as the default target:

```bash
systemctl set-default graphical.target
```
```bash
Removed '/etc/systemd/system/default.target'.
Created symlink '/etc/systemd/system/default.target' → '/usr/lib/systemd/system/graphical.target'.
```

Use the `systemctl` command to verify the default target:

```bash
systemctl get-default
```
```bash
graphical.target
```

## Use the Emergency and Rescue Targets

By appending either the `systemd.unit=rescue.target` or `systemd.unit=emergency.target` options to the kernel command line from the boot loader, the system enters into a rescue or emergency shell instead of a standard boot process. Both of these shells require the root password.

The emergency target mounts the root file system in read-only mode. At this point, the root user cannot change the /etc/fstab file until the drive is remounted in read/write mode by using the `mount -o remount,rw /` command.

In contrast, the rescue target waits for the `sysinit.target` unit to complete, so that more of the system is initialized, such as the logging service or the mounting of file systems with read/write access.

Administrators can use these shells to fix issues that prevent the system from booting as expected, for example, a dependency loop between services, or an incorrect entry in the `/etc/fstab` file. After you exit from these shells, the system continues with the standard boot process.

## Select a Different Target at Boot Time

To select a different target at boot time, append the `systemd.unit=target.target option` to the kernel command line from the boot loader.

For example, to boot the system into a rescue shell where you can change the system configuration with almost no services running, append the following option to the kernel command line from the boot loader:

```bash
systemd.unit=rescue.target
```

This configuration change affects only a single boot, and is a useful tool to troubleshoot the boot process.

To use this method to select a different target, follow these steps:

1. Boot or reboot the system.
2. In the GRUB2 menu, interrupt the countdown by pressing any key (except Enter, which initiates a regular boot).
3. Move the cursor to the kernel entry to start.
4. Press E to edit the current entry.
5. Move the cursor to the line that starts with linux, which is the kernel command line.
6. Append `systemd.unit=target.target`; for example, `systemd.unit=emergency.target`.
7. Press Ctrl+X to boot with these changes.

## Power off and Reboot

To power off or reboot a running system from the command line, you can use the `systemctl` command.

The `systemctl poweroff` command stops all running services, unmounts all file systems (or remounts them as read-only when they cannot be unmounted), and then powers down the system.

The `systemctl reboot` command stops all running services, unmounts all file systems, and then reboots the system.

You can also use the shorter version of these commands, `poweroff` and `reboot`, which are symbolic links to the `systemctl` unit equivalents.

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Note:</b><br><br>
The systemctl halt and halt commands are also available to stop the system. Unlike the poweroff command, these commands do not power off the system; they bring down a system to a point where it is safe to power it off manually.<br><br>
</div>

---
# Repairing Damaged File Systems at Boot Time
---

# File-system Issues

During the boot process, the systemd unit mounts the persistent file systems that are defined in the `/etc/fstab` file.

Errors in the `/etc/fstab` file or corrupted file systems can block a system from completing the boot process. In some failure scenarios, the system breaks out of the boot process and opens an emergency shell that requires the root user's password.

The following list describes some common file-system mounting issues when parsing the `/etc/fstab` file during the boot process:

### Corrupted file system

The `systemd` unit attempts to repair the file system. If the problem cannot be automatically repaired, then the system opens an emergency shell.

### Nonexistent storage device, device UUID, or mount point

The `systemd` unit times out waiting for the storage device to become available. If the device does not respond, then the system opens an emergency shell.


## Checking and Repairing File-system Corruption

Red Hat Enterprise Linux 10 provides tools to check and repair file-system issues. In the case of minor issues that are detected during boot, these utilities attempt to repair the file system automatically. For journal file systems, such as XFS and ext4, it might be only necessary to replay the journal, which is usually a quick operation. In the case of more severe file-system corruption issues, a system administrator can use the tools to check and repair file systems manually.

The tool that helps to keep file systems healthy during boot is generically known as the file system check tool, or the `fsck` command. However, the tool that repairs the XFS file system does not follow the same naming convention. Although there is an `fsck.xfs` binary file on the system, its only purpose is to satisfy boot requirements and immediately exits with an exit code of 0.

The `xfs_repair` command can check and repair issues with XFS file systems that an automatic repair does not fix.

```bash
xfs_repair block-device
```

To perform check and repair operations on `ext4` file systems, use the `fsck.ext4` command, which is a hard link to the `e2fsck` command that covers legacy `ext3` and `ext2` file systems as well. Use the `-p` option to automatically repair minor issues without user intervention.

```bash
fsck.ext4 -p block-device
```

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Warning:</b><br><br>
The proper procedure for repairing a file system is to mount and unmount the file system so that it replays the log files to avoid corrupted or residual data. Additionally, the file system must be unmounted before running the xfs_repair or e2fsck commands to avoid potential data loss or corruption.<br><br>
</div>


## Repairing File-system Issues at Boot

To access a system that cannot complete booting because of file-system issues, the `systemd` unit architecture provides an `emergency` boot target, which opens an emergency shell that requires the `root` password for access.

The following example shows the boot process output when the system finds a file-system issue and switches to the `emergency` target:

```bash
...output omitted...
[*     ] A start job is running for /dev/sda2 (27s / 1min 30s)
[ TIME ] Timed out waiting for device /dev/sda2.
[DEPEND] Dependency failed for /mnt/mountfolder
[DEPEND] Dependency failed for Local File Systems.
[DEPEND] Dependency failed for Mark need to relabel after reboot.
...output omitted...
[  OK  ] Started Emergency Shell.
[  OK  ] Reached target Emergency Mode.
...output omitted...
Give root password for maintenance
(or press Control-D to continue):
```

The `systemd` unit failed to mount the `/dev/sda2` device and timed out. Because the device is not available, the system opens an emergency shell for maintenance access.

To repair file-system issues when your system opens an emergency shell, first locate the errant file system, and then find and repair the fault. Now reload the `systemd` unit configuration to retry the automatic mounting.

Use the `mount` command to find which file systems are currently mounted by the `systemd` unit.


```bash
mount
```

```bash
...output omitted...
/dev/sda1 on / type xfs (ro,relatime,seclabel,attr2,inode64,noquota)
...output omitted...
```

Depending on which stage of the boot process the system is in when the issue appears, the root file system might still be mounted in read-only mode. If the root file system is mounted with the ro (read-only) option, then you cannot edit the `/etc/fstab` file. Temporarily remount the root file system with the `rw` (read/write) option to edit the `/etc/fstab` file. The remount option changes the mount parameters without unmounting the file system.

```bash
mount -o remount,rw /
```

Try to mount all the file systems that are listed in the `/etc/fstab` file by using the mount command `--all` option. This option processes every file-system entry, but skips those file systems that are already mounted. The command displays any errors that occur when mounting a file system.

```bash
mount --all
```

In this scenario, where the `/mnt/mountfolder` directory does not exist, create the `/mnt/mountfolder` directory before reattempting the mount. Other error messages can occur, including typing errors in the entries, or incorrect device names or UUIDs.

After you correct all issues in the `/etc/fstab` file, inform the systemd daemon to register the new `/etc/fstab` file by using the `systemctl daemon-reload` command.

```bash
systemctl daemon-reload
```

Then, reattempt mounting all the entries.


```bash
mount --all
```

The `systemd` unit processes the `/etc/fstab` file by transforming each entry into a mount type, and then starting the unit as a service. The `systemctl daemon-reload` command requests the `systemd` unit to rebuild and reload all unit configurations.

If the `mount` command `--all` option succeeds without further errors, then the final test is to verify that the file systems mount successfully during a system boot. Reboot the system and wait for the boot to complete.

```bash
systemctl reboot
```

For a quick test of the `/etc/fstab` file, use the `nofail` mount entry option. Using the `nofail` option in an `/etc/fstab` entry enables the system to boot even if that file-system mount is unsuccessful. This option must not be used with production file systems that must always mount. With the `nofail` option, an application could start when its file-system data is missing, with possibly severe consequences.



