# Managing Containers with Podman
---

## Container Technology Overview

In computing, a container is an encapsulated process that includes the required runtime dependencies for a program to run. In a container, application-specific libraries are independent of the host operating system libraries. The host operating system and kernel provide libraries and functions that are not specific to the containerized application. The provided libraries and functions help to ensure that the container remains compact, and that it can quickly execute and stop as needed.

A container engine creates a union file system by merging container image layers. A layer is a component of the container image that represents a specific set of files or changes, such as system libraries, application binaries, or configuration files. Each layer builds on the previous one, forming a stacked structure that makes up the complete image. Because container image layers are immutable, a container engine adds a writable layer for runtime file modifications. Containers are ephemeral by default, which means that the container engine removes the writable layer when you remove the container.

![alt text](images/image24.png)

The environment within a container is Linux-based, regardless of the host operating system. Containers use Linux kernel features, such as namespaces, control groups (cgroups), SELinux, and secure computing mode (seccomp). For example, containers use cgroups for resource management, such as CPU time allocation and system memory. Namespaces in particular provide the functionality to isolate processes within containers from each other and from the host system. When using containers on non-Linux operating systems, these Linux-specific features are often virtualized by the container engine implementation.

Containerization originated from technologies such as the `chroot` utility, a method to partially or fully isolate an environment, and evolved to the Open Container Initiative (OCI), which is a governance organization that defines standards for creating and running containers. Most container engines conform to the OCI specifications, so developers can confidently build their deployable target artifacts to run as OCI containers.

Containers use SELinux and secure computing mode to enforce security boundaries and to restrict the features that are available in containers.

## Benefits and Challenges of Using Containers

One of the main benefits is that containers can start in seconds, which makes them ideal for dynamic and scalable environments. They are also well suited for deploying modern applications, such as cloud-native applications. They are highly efficient, as they use fewer resources compared to virtual machines. Containers are portable, which means that they run consistently across development, testing, and production environments. Their isolated nature ensures that application environments remain separate and predictable.

However, containers also present some challenges. Data persistence requires additional configuration, such as using volumes to store data outside of the container's ephemeral storage. Networking becomes more complex in configurations that involve multiple containers or multiple hosts. Security management is another concern, as containers share the host's kernel and require careful access control. Although rootless containers improve security by allowing users to run containers without elevated privileges, rootless containers might also limit access to certain system functions.

## Images Versus Instances

Container images and container instances are commonly used terms when working with containers, and they have different meanings. A container image contains immutable data, instructions, and libraries that define an application. You can use container images to create container instances, which are executable versions of the image that include references to networking, disks, and other runtime necessities.

You can use a single container image multiple times to create many distinct container instances. You can also run these instances across multiple hosts. The application within a container is independent of the host environment.

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Note:</b><br><br>
OCI container images are defined by the image-spec specification, whereas OCI container instances are defined by the runtime-spec specification.<br><br>
</div>

Another way to think about container images versus container instances is that an instance relates to an image as an object relates to a class in object-oriented programming.

## Container Registries

A container image registry is a storage location that hosts container images and related artifacts for container-based applications. The `/etc/containers/registries.conf` file is a system-wide configuration file. This file lists the container registries that are available for tools like Podman, Buildah, and Skopeo.

Red Hat provides the following registries:

- registry.redhat.io : requires authentication
- registry.access.redhat.com : requires no authentication
- registry.connect.redhat.com : holds Red Hat Partner Connect program images

## Comparing Containers to Virtual Machines

Containers generally serve a similar role to virtual machines (VMs), where an application resides in a self-contained environment with virtualized networking for communication. Despite this initial similarity, containers have a smaller footprint, and start and stop faster than a virtual machine. For both memory and disk usage, VMs are often measured in gigabytes, whereas containers are measured in megabytes.

A VM is useful when an additional full computing environment is required, such as when an application requires specific, dedicated hardware. Additionally, a VM is preferable when an application requires a non-Linux operating system or a different kernel from the host.

## Containers Versus Virtual Machines

Virtual machines and containers use different software for management and functionality. Hypervisors, such as Kernel-based Virtual Machine (KVM), Xen, VMware, and Hyper-V, are applications that provide the virtualization functionality for VMs. The container equivalent of a hypervisor is a container engine, such as Podman.

| Feature / Aspect              | Virtual Machines                     | Containers                            |
|-------------------------------|--------------------------------------|---------------------------------------|
| **Machine-level functionality** | Hypervisor                          | Container engine                      |
| **Management**                 | VM management interface              | Container engine or orchestration software |
| **Virtualization level**       | Fully virtualized environment        | Only relevant parts                   |
| **Size**                       | Measured in gigabytes                | Measured in megabytes                 |
| **Portability**                | Generally only same hypervisor       | Any OCI-compliant engine              |


You can manage hypervisors with additional management software. The software can be included with the hypervisor, or it can be external, such as Virtual Machine Manager (virt-manager) with KVM. Alternatively, you can manage containers directly through the container engine itself. Additionally, you can use container orchestration tools, such as Red Hat OpenShift Container Platform (RHOCP) and Kubernetes, to run and manage containers at scale. RHOCP manages both containers and virtual machines from a common interface.

With VMs, interoperability is uncommon. A VM that runs on one hypervisor is usually not guaranteed to run on a different hypervisor. In contrast, containers that follow the OCI specification do not require a particular container engine to function. Many container engines can function as drop-in replacements for each other.

---
# Running Containers with Podman
---

## The Podman Container Management Tool

Podman is an open source tool for managing your containers locally. With Podman, you can find, run, build, or deploy Open Container Initiative (OCI) containers and container images.

Some container tools use a daemon to proxy the requests, which creates a single point of failure for container management tasks. In addition, a daemon might require elevated privileges, which might become a security concern.

Podman is daemonless by design, which means that Podman interacts directly with containers, images, and registries without a daemon. This design makes Podman a suitable tool to use in a production environment.

In Red Hat Enterprise Linux 10, Podman is installed by default. You can verify the Podman version that is installed in your machine by using the podman -v command. The version number might differ in your system.

```bash
podman -v
```

Podman provides three ways to interact with your containers: the Podman CLI, the RESTful API, and a desktop application named Podman Desktop.

This section focuses on running containers by using the Podman CLI.

## Container Image Registries

A container image is a packaged version of your application, with all the dependencies that are necessary for the application to run. You can download a container image from a container registry, and use this container image as a base to run your containers. Commonly used image registries include Red Hat Registry, Quay.io, Docker Hub, and Amazon Elastic Container Registry (Amazon ECR).

## Red Hat Container Registries

Red Hat distributes container images by using the following registries:

- `registry.redhat.io` : requires authentication
- `registry.access.redhat.com` : requires no authentication
- `registry.connect.redhat.com` : holds Red Hat Partner Connect program images

Red Hat Ecosystem Catalog provides centralized searching for these registries at https://catalog.redhat.com. You can use the Ecosystem Catalog to search for images and to get technical details about them. Go to https://catalog.redhat.com/search to search for container images.

![alt text](images/image25.png)

The container image details page provides relevant information about the container image, such as the Containerfile that is used to create the image, the packages that are installed within the image, or a security scanning. You can also change the image version by selecting a specific tag.

## The Quay.io Container Registry

The Red Hat Registry stores only images from Red Hat and certified providers. To store your custom images, you can use the Quay.io registry. Storing public images in Quay.io is free, and paying customers receive further benefits, such as private repositories. Developers can also deploy an on-premise Quay instance, which you can use to set up an image registry on your infrastructure.

You can use your Red Hat developer account to log in to the Quay.io registry.

## Logging in to Container Image Registries

Usually, you provide authentication credentials to interact with a container registry by using the podman login command. The podman login command accepts the registry URL as an argument and then it requests the username and password.

The following example shows a login attempt to the `registry.redhat.io` registry with a username and password.

```bash
podman login registry.redhat.io
```

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Note:</b><br><br>
For security reasons, the podman login command does not show your password in the interactive session. Although you do not see what you are typing, Podman registers every key stroke. Press Enter when you have typed your full password in the interactive session to initiate the login.<br><br>
</div>

Some container registries might not require you to provide an authorized account, which means that you can download container images without providing credentials. In this case, you must provide the URL of the container image registry and leave the username and password information empty.

```bash
podman login registry.access.redhat.com
```

## Inspecting Configured Container Registries


