# Matching Text with Regular Expressions
---

## Write Regular Expressions

Regular expressions provide a pattern matching mechanism to find specific content. The grep, less, and vim commands are some of the commands that can use regular expressions.

Programming languages such as C, Python, and Rust also support regular expressions, and might differ slightly in syntax.

Regular expressions are a unique language, with their own syntax and rules. This section introduces regular expression syntax as implemented in Bash, with examples.

## A Simple Regular Expression

The simplest regular expression is an exact match of the string to search. An exact match occurs when the characters in the regular expression match the type and order of the string.

Imagine that a user is looking through the following file for all occurrences of the cat pattern:

```bash
cat
dog
concatenate
dogma
category
educated
boondoggle
vindication
chilidog
```

The cat string is an exact match of the c character, followed by the a and t characters with no other characters in between. Searching the file with the cat string as the regular expression returns the following matches:

```bash
cat
concatenate
category
educated
vindication
```

## Match the Start and End of a Line

A regular expression matches the search string anywhere on the line in which it occurs: at the beginning, middle, or end of the word or line. Use a line anchor metacharacter to control where to look for a match on a line.

To match only at the beginning of a line, use the caret character (^). To match only at the end of a line, use the dollar sign ($).

Using the same file as in the previous example, the `^cat` regular expression matches two lines.

```bash
cat
category
```

The `cat$` regular expression finds only one match, where the cat characters occur at the end of a line.

```bash
cat
```

Locate lines in the file that end with dog by using an end-of-line anchor to create the `dog$` regular expression. This example matches two lines:

```bash
dog
chilidog
```

To locate a line that contains only the exact search expression, use both the beginning and end-of-line anchors. For example, to locate the word cat when it is both at the beginning and at the end of a line simultaneously, use `^cat$`.

```bash
cat
```

## Basic and Extended Regular Expressions

The two types of regular expressions are basic regular expressions and extended regular expressions.

One difference between basic and extended regular expressions is in the behavior of the |, +, ?, (, ), {, and } special characters. In basic regular expression syntax, these characters have a special meaning only if they are prefixed with a backslash \ character. In extended regular expression syntax, it is exactly the opposite: these characters have a special meaning unless they are prefixed with a backslash character.

Other minor differences apply to how the ^, $, and * characters are handled.

The `grep`, `sed`, and `vim` commands use basic regular expressions. The `grep` command `-E` option, the `sed` command -E option, and the `less` command use extended regular expressions.

## Wildcard and Multiplier Usage in Regular Expressions

egular expressions use a period character (`.`) as a wildcard to match any single character on a single line. The `c.t` regular expression searches for a string that contains `c`, followed by any single character, followed by `t`.

Example matches might include cat, concatenate, vindication, cut, and c$t.

With an unrestricted wildcard, you cannot predict the character that matches the wildcard. To match specific characters, replace the unrestricted wildcard with appropriate characters.

The use of bracket characters, such as in the `c[aou]t` regular expression, matches patterns that start with `c`, followed by `a`, `o`, or `u`, followed by `t`. Possible matching expressions can have the cat, cot, or cut strings.

Multipliers are another mechanism for use as a wildcard. Multipliers apply to the previous character or wildcard in the regular expression. An often used multiplier is the asterisk (*) character. When used in a regular expression, the asterisk multiplier matches zero or more occurrences of the multiplied expression. You can use the asterisk with expressions, in addition to characters.

For example, the `c[aou]*t` regular expression might match coat or coot. A regular expression of `c.*t` matches cat, coat, culvert, and even `ct` (matching zero characters between c and t). Any string that starts with c, is followed by zero or more characters, and ends with t must be a match.

Another type of multiplier indicates a more precise number of characters in the pattern. An example of an explicit multiplier is the 'c.{2}t' regular expression, which matches any word that begins with c, followed by exactly any two characters, and ends with t. The 'c.{2}t' expression would match two words in the following example:

```bash
cat
coat
convert
cart
covert
cypher
```
Note

    This course introduced two metacharacter text parsing mechanisms: shell pattern matching (which is also known as file globbing or file name expansion), and regular expressions. Both mechanisms use similar metacharacters, such as the asterisk character, with differences in metacharacter interpretation and rules.

    Pattern matching is a shell technique to specify multiple file names on the command line. Regular expressions represent any form or pattern in text strings, no matter how complex. Regular expressions are internally supported by many text processing commands and languages such as awk, grep, python, rust, sed, and many other applications.

**Basic and Extended Regular Expression Syntax**

| Basic syntax | Extended syntax | Description |
|--------------|-----------------|-------------|
| .            |                 | The period (.) matches any single character. |
| ?            |                 | The preceding item is optional and is matched at most once. |
| *            |                 | The preceding item is matched zero or more times. |
| +            |                 | The preceding item is matched one or more times. |
| \{n\}        | {n}             | The preceding item is matched exactly n times. |
| \{n,\}       | {n,}            | The preceding item is matched n or more times. |
| \{,m\}       | {,m}            | The preceding item is matched at most m times. |
| \{n,m\}      | {n,m}           | The preceding item is matched at least n times, but not more than m times. |
| [:alnum:]    |                 | Alphanumeric characters: [:alpha:] and [:digit:]; in the 'C' locale and ASCII character encoding, this expression is the same as [0-9A-Za-z]. |
| [:alpha:]    |                 | Alphabetic characters: [:lower:] and [:upper:]; in the 'C' locale and ASCII character encoding, this expression is the same as [A-Za-z]. |
| [:blank:]    |                 | Blank characters: space and tab. |
| [:cntrl:]    |                 | Control characters. In ASCII, these characters have octal codes 000 through 037, and 177 (DEL). |
| [:digit:]    |                 | Digits: 0 1 2 3 4 5 6 7 8 9. |
| [:graph:]    |                 | Graphical characters: [:alnum:] and [:punct:]. |
| [:lower:]    |                 | Lowercase letters; in the 'C' locale and ASCII character encoding: a–z. |
| [:print:]    |                 | Printable characters: [:alnum:], [:punct:], and space. |
| [:punct:]    |                 | Punctuation characters; in the 'C' locale and ASCII character encoding: ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ' { | } ~. |
| [:space:]    |                 | Space characters: in the 'C' locale, it is tab, newline, vertical tab, form feed, carriage return, and space. |
| [:upper:]    |                 | Uppercase letters; in the 'C' locale and ASCII character encoding: A–Z. |
| [:xdigit:]   |                 | Hexadecimal digits: 0–9 A–F a–f. |
| \b           |                 | Match the empty string at the start or end of a word. |
| \B           |                 | Match the empty string provided that it is not at start or end of a word. |
| \<           |                 | Match the empty string at the start of a word. |
| \>           |                 | Match the empty string at the end of a word. |
| \w           |                 | Match the word constituent. Synonym for [_[:alnum:]] |
| \W           |                 | Match the non-word constituent. Synonym for [^_[:alnum:]] |
| \s           |                 | Match white space. Synonym for [[:space:]] |
| \S           |                 | Match non-white space. Synonym for [^[:space:]] |


## Match Regular Expressions from the Command Line

The `grep` command uses regular expressions to isolate matching data. You can use the `grep` command to match data in a single file or in multiple files. When you use grep to match data in multiple files, it prints the file name followed by a colon character and then the lines that match the regular expression.

## Isolate Data with the Grep Command

The `grep` command specifies a regular expression and a file to parse for matches.

```bash
grep '^computer' /usr/share/dict/words
```

Note

    It is recommended practice to use single quotation marks to encapsulate the regular expression to protect any shell metacharacters (such as the $, *, and {} characters). Encapsulating the regular expression ensures that the command, not the shell, interprets the characters.

The `grep` command can process output from other commands by using a pipe operator character (`|`). The following example shows the grep command parsing lines from the output of another command.

```bash
ps aux | grep chrony
```

## Grep Command Options

The `grep` command has many options for controlling how it parses lines.

**Table of Common Grep Options**

| Option   | Function                                                                 |
|----------|---------------------------------------------------------------------------|
| -i       | Use the provided regular expression and do not enforce case sensitivity (run case-insensitive). |
| -v       | Display only lines that do not contain matches to the regular expression. |
| -r       | Search for data that matches the regular expression recursively in a group of files or directories. |
| -A NUMBER| Display NUMBER of lines after the regular expression match.               |
| -B NUMBER| Display NUMBER of lines before the regular expression match.              |
| -e       | If multiple -e options are used, then multiple regular expressions can be supplied and are used with a logical OR. |
| -E       | Use extended instead of basic regular expression syntax when parsing the provided regular expression. |


View the `man` pages to find other options for the `grep` command.

## Examples of the Grep Command

The following examples use various configuration files and log files.

Regular expressions are case-sensitive by default. Use the `grep` command `-i` option to run a case-insensitive search. The following example shows an excerpt of the `/etc/httpd/conf/httpd.conf` configuration file:

```bash
cat /etc/httpd/conf/httpd.conf
```

The following example searches for the serverroot regular expression in the `/etc/httpd/conf/httpd.conf` configuration file.

```bash
grep -i serverroot /etc/httpd/conf/httpd.conf
```

Use the grep command `-v` option to reverse search the regular expression. This option displays only the lines that do not match the regular expression.

In the following example, all lines, regardless of case, that do not contain the server regular expression are returned.

```bash
grep -v -i server /etc/hosts
```

To view a file without the distraction of comment lines, use the grep command -v option. In the following example, the regular expression matches and excludes all the lines that begin with a hash character (#) or a semicolon (;) in the `/etc/systemd/system/multi-user.target.wants/rsyslog.service` file. In that file, the hash character at the beginning of a line indicates a general comment, whereas the semicolon refers to a commented variable value.

```bash
grep -v '^[#;]' /etc/systemd/system/multi-user.target.wants/rsyslog.service
```

The `grep` command `-e` option can search for more than one regular expression at a time. The following example, which uses a combination of the less and grep commands, locates all occurrences of pam_unix, user root, and Accepted publickey in the `/var/log/secure` log file.

```bash
grep -e 'pam_unix' -e 'user root' -e 'Accepted publickey' \
/var/log/secure | less
```

To search for text in a file that you opened with the less or vim command, first enter the slash character (/) and then type the pattern to find. Press Enter to start the search. Press N to find the next match.

```bash
user@host:~$ sudo less /var/log/messages
...output omitted...
May 19 19:28:51 host kernel: SCSI subsystem initialized
May 19 19:28:51 host kernel: ACPI: bus type USB registered
May 19 19:28:51 host kernel: usbcore: registered new interface driver usbfs
May 19 19:28:51 host kernel: usbcore: registered new interface driver hub
May 19 19:28:51 host kernel: usbcore: registered new device driver usb
May 19 19:28:51 host kernel: pps_core: LinuxPPS API ver. 1 registered
/usb$
```

```bash
root@host:~# vim /etc/chrony.conf
# Use public servers from the pool.ntp.org project.
# Please consider joining the pool (http://www.pool.ntp.org/join.html).
#server 0.rhel.pool.ntp.org iburst
#server 1.rhel.pool.ntp.org iburst
#server 2.rhel.pool.ntp.org iburst
#server 3.rhel.pool.ntp.org iburst
server 172.25.254.254 iburst

# Ignore stratum in source selection.
stratumweight 0

# Record the rate at which the system clock gains/losses time.
driftfile /var/lib/chrony/drift

...output omitted...

# Serve time even if not synchronized to any NTP server.
#local stratum 10
/[Nn][Tt][Pp]
```
