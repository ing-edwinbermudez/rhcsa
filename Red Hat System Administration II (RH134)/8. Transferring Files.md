# Transferring Files Between Systems
---

## Transfer Remote Files with the Secure File Transfer Program

The OpenSSH suite securely runs shell commands on remote systems. Use the Secure File Transfer Program (SFTP) to interactively upload files to or download files from an SSH server. This program is part of the OpenSSH suite. A session with the sftp command uses the secure authentication mechanism and encrypted data transfer to and from the SSH server.

Specify a remote location for the source or destination of the files to copy. For the format of the remote location, use `user@host:path`. The user@ part of the argument is optional; if this part is missing, then the sftp command uses the current local user to log in as the remote user.

When you run the `sftp` command by providing the remote user and host, the terminal opens an interactive session.

```bash
sftp remoteuser@remotehost
```

The interactive `sftp` session accepts various commands that work the same way in the remote file system as in the local file system, such as the `ls`, `cd`, `mkdir`, `rmdir`, and `pwd` commands.

- The `put` command uploads a file to the remote system.
- The `get` command downloads a file from the remote system.
- The `exit` command exits the sftp session.

List the available `sftp` commands by using the `help` command in the `sftp` session:

```bash
sftp> help
Available commands:
bye                                Quit sftp
cd path                            Change remote directory to 'path'
chgrp [-h] grp path                Change group of file 'path' to 'grp'
chmod [-h] mode path               Change permissions of file 'path' to 'mode'
chown [-h] own path                Change owner of file 'path' to 'own'
...output omitted...
```

In an `sftp` session, you might run some commands on your local host by using the `l` character before the command.

For example, the `pwd` command prints the current working directory on the remote host.

```bash
pwd
```

To print the current working directory on your local host, use the `lpwd` command.

```bash
lpwd
```

In the following example, upload the `/etc/hosts` file from the local system to the newly created `/home/remoteuser/hostbackup` directory on the remotehost system

```bash
mkdir hostbackup
cd hostbackup
```

Change to the `hostbackup` directory on the remotehost system.

```bash
cd hostbackup
```

The `sftp` session expects that the `put` command is followed by a local file in the connecting user's home directory, in this case the `/home/remoteuser` directory:

```bash
put /etc/hosts
```

To copy a whole directory tree recursively, use the `sftp` command `-r` option.

The following example recursively copies the `/home/user/directory` local directory to the `remotehost` machine.

```bash
put -r directory
```

To download the `/etc/dnf/dnf.conf` file from the remote host to the current directory on the local system, use the `get` command.

```bash
get /etc/dnf/dnf.conf
```

To get a remote file with the `sftp` command on a single command line, without opening an interactive session, use the following syntax. You cannot use single command-line syntax to put files on a remote host.

```bash
sftp remoteuser@remotehost:/home/remoteuser/remotefile
```

## Transfer Files with the Secure Copy Command

The `Secure Copy Protocol (SCP)` uses the `scp` command, which is also part of the OpenSSH suite, and copies files from a remote system to the local system, or from the local system to a remote system.

Starting in RHEL 10, the `scp` command uses SFTP to transfer files.

You can specify a remote location for the source or destination of the files that you are copying. The `scp` command uses the `user@host` remote username with hostname/IP address to identify the target system and user. If you do not specify a user, then the command attempts to log in as a remote user by using the current local user.

The `scp` command can also transfer files with the legacy SCP. This protocol contains a code injection vulnerability, therefore Red Hat recommends that you do not use the `scp` command with the legacy SCP. To revert to the legacy `scp` protocol, you can include the `-O` flag.

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Important:</b><br><br>
Starting in RHEL 10, the use of the scp protocol can be disabled on the system. If the file /etc/ssh/disable_scp exists, then any attempt to use the scp protocol might fail, and the -O option cannot be used, but the sftp protocol still works.<br><br>
</div>

he following example demonstrates how to copy the local `/etc/dnf/dnf.conf` and `/etc/hosts` files to the remote host's home directory:

```bash
scp remoteuser@remotehost:/etc/hostname /home/user
```

---
# Synchronizing Content Between Systems
---

## Synchronize Remote Files and Directories

The `rsync` command is another way to copy files from one system to another system securely. The tool uses an algorithm that minimizes copied data by synchronizing only the changed portions of files. If two files or directories are similar between two servers, then the `rsync` command copies only the differences between the file systems.

An advantage of the `rsync` command is that it copies files efficiently and securely between a local system and a remote system. Whereas an initial directory synchronization takes similar time to copying it, subsequent synchronizations copy only the differences over the network, which substantially accelerates updates.

Use the `rsync` command `-n` option for a dry run, to simulate what happens when the command is executed. The dry run shows the changes that the rsync command would perform when executing the command. Perform a dry run before the actual rsync command operation to ensure that no critical files are overwritten or deleted.

When synchronizing with the `rsync` command, two standard options are the `-v` and `-a` options.

The rsync command -v or --verbose option provides a more detailed output. This option is helpful for troubleshooting and viewing live progress.

The `rsync` command `-a` or `--archive` option enables archive mode. This option enables recursive copying and turns on other options to preserve most characteristics of the files.

Archive mode is the same as specifying the following options:

**Table 8.1. Options in Archive Mode**

| Option       | Description                                              |
|--------------|----------------------------------------------------------|
| `-r, --recursive` | This option synchronizes the whole directory tree recursively. |
| `-l, --links`     | This option synchronizes symbolic links.             |
| `-p, --perms`     | This option preserves permissions.                   |
| `-t, --times`     | This option preserves time stamps.                   |
| `-g, --group`     | This option preserves group ownership.               |
| `-o, --owner`     | This option preserves the owner of the files.        |
| `-D, --devices`   | This option preserves device files.                  |

Archive mode does not preserve hard links, because it might add significant time to the synchronization. Use the rsync command -H option to preserve hard links.

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Note:</b><br><br>
To include extended attributes when synchronizing files, add these options to the rsync command:<br><br>

-A to preserve Access Control Lists (ACLs)<br><br>
-X to preserve SELinux file contexts<br><br>
</div>

You can use the `rsync` command to synchronize the contents of a local file or directory with a file or directory on a remote machine, with either machine as the source. You can also synchronize the contents of two local files or directories on the same machine.

Like the `sftp` command, the `rsync` command specifies remote locations in the user@host:path format. The remote location can be either the source or the destination system, provided that either one machine is a remote system and the other is a local system, or both machines are local systems.

To preserve file ownership on the destination system, you must be the `root` user. If the destination is remote, then authenticate as the `root` user. If the destination is local, then you must run the `rsync` command as the root user.

The following example synchronizes the local `/var/log` directory from the host machine to the `/tmp` directory on the `hosta` system:

```bash
rsync -av /var/log hosta:/tmp
```

The following example synchronizes the `/var/log` remote directory from the hosta machine to the `/tmp` directory on the 000host machine:

```bash
rsync -av hosta:/var/log /tmp
```

The following example synchronizes the contents of the `/var/log` directory to the `/tmp` directory on the same machine and uses the sudo command to escalate to the `root` user:


```bash
sudo rsync -av /var/log /tmp
```

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Important:</b><br><br>
Correctly specifying a trailing slash with a source directory is important. A trailing slash with a source directory synchronizes the contents of the directory without including the directory itself. The contents are synchronized directly into the destination directory.<br><br>

Without the trailing slash, the source directory itself might synchronize to the destination directory. The source directory's contents are in the new subdirectory in the destination.<br><br>
Bash tab-completion automatically adds a trailing slash to directory names.<br><br>
</div>


In this example, the contents of the `/var/log/` directory are synchronized to the `/tmp` directory instead of to the log directory that is created in the `/tmp` directory.

```bash
rsync -av /var/log/ /tmp
ls /tmp
```