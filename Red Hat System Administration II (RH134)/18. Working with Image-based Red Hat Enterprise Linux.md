# Image Mode for Red Hat Enterprise Linux

## Introduction to Image Mode

Image mode for Red Hat Enterprise Linux 10 is a new deployment and management approach that uses container-native tools to build, deploy, and manage the operating system. With this method, you can deploy the operating system from a bootable container (bootc) image.

![alt text](images/image26.png)

Container technology has existed for many years and has proven successful at deploying applications. The same efficient technique of using layered images can be applied to entire hosts. However, the base image is more complex than the ones that application containers use. A bootable container image must include the kernel, a boot loader, and other operating system components that are typically excluded from application containers.

Red Hat provides bootc base images for AMD/Intel x86_64 and the 64-bit ARM architectures. You can build your own derived image from the base image by adding your chosen application software and its dependencies.

## The Image Mode Workflow

Image mode introduces a container-native approach to system administration. Building a bootc container image is the foundation. This image is then deployed to various target systems. Management operations that follow the initial deployment involve updating the original container image and target systems fetching the new operating system updates from the registry.

![alt text](images/image27.png)


**Build**

You can define your entire operating system by using a standard Containerfile. The file specifies the base bootc image to use as the starting point and provides additional build instructions for the image as needed. You can use the Podman tool to build and tag the container image.

**Deploy**

When the build is complete, the bootable container image must be pushed to a registry that target systems can access. The registry is the source of truth during initial deployment as well as during continued management of your systems.

The Anaconda installer for Red Hat Enterprise Linux supports image mode to deploy to bare metal as well as to virtual machine targets by using Kickstart automation.

For cloud environments, Red Hat provides the bootc-image-builder containerized tool to help create disk images of various types from bootc images. Supported formats include: qcow2 (QEMU), ami (Amazon), vmdk (vSphere), and gce (Google).

**Manage**

On systems that are deployed in image mode, the bootc command-line tool can manually fetch updates that are delivered in the form of container images and install them on the system. By default, target systems automatically update themselves when a later version of their bootc image is tagged in the container registry. Because the updates are transactional, a reboot is always required. The bootc command also supports rollbacks by updating the boot-loader entry to point to a previous installed deployment.

## Benefits of Image Mode

Compared to traditional package mode, image mode offers several advantages.

**Limited infrastructure drift**

Infrastructure drift is a challenge in today's cloud environments, when systems gradually deviate from the intended state due to manual configuration changes. Image mode limits infrastructure drift by using well-established container tools and techniques.

**Immutable operating system**

In image mode, the root file system is immutable by default and application updates are atomic. The /etc and /var directories are designated to store mutable machine local data. The immutable design enhances stability and security.

**System definition committed to version control**

A Containerfile is now a simplified blueprint for the operating system, to include system configuration and application files. Bootable containers are built by using existing tools such as Podman.

**Better scalability**

Container images are fast to build and later updates are efficiently stored in additional image layers. An organization can maintain a handful of images and deploy them on many systems in large data center environments.

**Simplified troubleshooting**

System updates are atomic and are delivered in the form of updated container images that can be rolled back if needed.

---
#Creating Installable Images for Image Mode.
---

## The Containerfile Format

When using image mode for Red Hat Enterprise Linux, you deploy software, associated dependencies, and configuration files to hosts by using container images that conform to the Open Container Initiative (OCI) standard. Container images deliver operating system updates that can also be rolled back if necessary.

You can use existing and familiar tools such as Podman to build container images. A key piece of the build process is the Containerfile, which is widely used to create application containers and has the benefit of a standardized format.

![alt text](images/image28.png)

By adding a series of instructions to a Containerfile, you can customize an image to meet your needs. Each line in the Containerfile creates an image layer, which means that instructions are executed independently. During the build process, each instruction runs in an independent container by using an intermediate image built from the previous commands.

The following example Containerfile builds a typical application container:

```bash
# Use the ubi10 base image
FROM registry.redhat.io/ubi10 #1

# Install httpd
RUN dnf install -y httpd #2

# Copy a temporary index.html file to the web server root
COPY index.html /var/www/html/index.html #3

# Expose port 80 for httpd
EXPOSE 80 #4

# Set the entrypoint to run httpd in the foreground
ENTRYPOINT ["/usr/sbin/httpd", "-DFOREGROUND"] #5
```

1. The Red Hat Universal Base Image is the foundation for this application container.

2. The Apache HTTP service is layered on top of the base image.

3. The index.html file is copied from the project directory into the expected location in the container.

4. The `EXPOSE` instruction documents which port the service listens on at runtime. The HTTP port is TCP/80, which is defined in the standard Apache configuration file that ships in the httpd RPM package.

5. The `ENTRYPOINT` instruction defines the executable to run and any arguments to be passed to it when the container starts.

Although this sample Containerfile is sufficient for creating an application container, the approach to build a bootable container is somewhat different. Most importantly, the base image must be a specialized image that includes the required components for a full operating system, such as the kernel, a boot loader, and the systemd service manager. Red Hat provides the `rhel-bootc` base image, which incorporates tooling from the OSTree, `composefs`, and `bootc upstream` projects to enable image mode for RHEL.


<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Important:</b><br><br>
Red Hat Enterprise Linux in image mode and the rhel-bootc image are subject to the Red Hat Enterprise Linux end user license agreement (EULA). Therefore, you cannot publicly redistribute the base or any derivative user-created images.<br><br>
</div>

For example, the following Containerfile installs and enables the httpd package on top of the rhel-bootc image. Note the differences from the previous application container example.

```bash
# Use the rhel-bootc base image
FROM registry.redhat.io/rhel10/rhel-bootc:latest #1

# Install and enable httpd
RUN dnf -y install httpd mod_ssl && dnf clean all #2
RUN systemctl enable httpd && firewall-cmd --add-service=https #3

# Add httpd related files
ADD ./etc/ /etc #4
COPY ./index.html /var/www/html/index.html 
```

1. The `FROM` line directs Podman to use the rhel-bootc container image as a base.

2. The `RUN` lines execute the command sequence within the container, creating new image layers in the process.

3. Because the image is for RHEL in image mode, this Containerfile enables the httpd service instead of configuring an `ENTRYPOINT` or `CMD` instruction. Additionally, this Containerfile opens the firewall for HTTPS instead of using an `EXPOSE` instruction.

4. The `ADD` line includes a file or directory at the destination within the container. The `ADD` command can resolve files over the network or unpack files within an archive in addition to local files.

5. The `COPY` command copies a file or directory at a relative path to the destination location. The COPY command does not unpack files within an archive, and instead copies archive files directly into the container.

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Note:</b><br><br>
The Containerfile(5) manual page details the full specification for the Containerfile format. Many commands can take additional options and arguments, which you can use to significantly customize the resulting container image.<br><br>
</div>

Some `Containerfile` commands have no effect for RHEL in image mode:

- The `ENTRYPOINT` and `CMD` instructions are replaced by starting services via the systemd service manager.

- The `ENV` instruction is replaced by configuring the systemd service.

- The `EXPOSE` instruction is only for documenting application ports. In image mode, you can control access to ports by using firewall configuration.

- The `USER` instruction is replaced by runtime user management.

Although these commands do not affect a RHEL system in image mode, you can still use commands such as the `ENV` command to facilitate intermediate steps in a Containerfile. For example, you might decide to define a list of packages by using the `ENV` command, and then install those packages later by using a `RUN` command

## Building Bootable Container Images

You can use the `podman build` command to build a bootc image from the command line. Podman uses a Containerfile in the specified directory to build a container image. The `--squash` option merges all new layers into a single layer, which reduces the image's complexity and layer count.

```bash
podman build --squash -t \
registry.example.com/user/webserver-bootc:latest .
```

After building an image, you can push the image to an image repository by using the podman push command.

```bash
podman push registry.example.com/user/webserver-bootc:latest
```

## Testing a Bootable Image in Application Mode

To test a bootable container before deploying it, use the `podman run` command to launch the container locally. The following example starts the `registry.example.com/user/webserver` container image and forwards the `8080` port to port `80` in the container:

```bash
podman run -d -p 8080:80 registry.example.com/user/webserver
```

You can then verify that the container functions as you expect. In this case, you can verify that the web server is accessible on port 8080 by using the curl command.

```bash
curl http://localhost:8080
```

You can also validate functionality by viewing the running processes in the container with the podman exec command.

```bash
podman exec -l ps -ef
```

Notice that PID 1 is the init process. The init process is the systemd service manager, which started the httpd service.

When running a `bootc-based` container in application mode, the included RHEL kernel does not start. Processes run in the context of the container platform, which is podman in this example.


