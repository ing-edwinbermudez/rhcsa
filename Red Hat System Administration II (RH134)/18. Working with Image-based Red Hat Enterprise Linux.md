# Image Mode for Red Hat Enterprise Linux

## Introduction to Image Mode

Image mode for Red Hat Enterprise Linux 10 is a new deployment and management approach that uses container-native tools to build, deploy, and manage the operating system. With this method, you can deploy the operating system from a bootable container (bootc) image.

![alt text](images/image26.png)

Container technology has existed for many years and has proven successful at deploying applications. The same efficient technique of using layered images can be applied to entire hosts. However, the base image is more complex than the ones that application containers use. A bootable container image must include the kernel, a boot loader, and other operating system components that are typically excluded from application containers.

Red Hat provides bootc base images for AMD/Intel x86_64 and the 64-bit ARM architectures. You can build your own derived image from the base image by adding your chosen application software and its dependencies.

## The Image Mode Workflow

Image mode introduces a container-native approach to system administration. Building a bootc container image is the foundation. This image is then deployed to various target systems. Management operations that follow the initial deployment involve updating the original container image and target systems fetching the new operating system updates from the registry.

![alt text](images/image27.png)


**Build**

You can define your entire operating system by using a standard Containerfile. The file specifies the base bootc image to use as the starting point and provides additional build instructions for the image as needed. You can use the Podman tool to build and tag the container image.

**Deploy**

When the build is complete, the bootable container image must be pushed to a registry that target systems can access. The registry is the source of truth during initial deployment as well as during continued management of your systems.

The Anaconda installer for Red Hat Enterprise Linux supports image mode to deploy to bare metal as well as to virtual machine targets by using Kickstart automation.

For cloud environments, Red Hat provides the bootc-image-builder containerized tool to help create disk images of various types from bootc images. Supported formats include: qcow2 (QEMU), ami (Amazon), vmdk (vSphere), and gce (Google).

**Manage**

On systems that are deployed in image mode, the bootc command-line tool can manually fetch updates that are delivered in the form of container images and install them on the system. By default, target systems automatically update themselves when a later version of their bootc image is tagged in the container registry. Because the updates are transactional, a reboot is always required. The bootc command also supports rollbacks by updating the boot-loader entry to point to a previous installed deployment.

## Benefits of Image Mode

Compared to traditional package mode, image mode offers several advantages.

**Limited infrastructure drift**

Infrastructure drift is a challenge in today's cloud environments, when systems gradually deviate from the intended state due to manual configuration changes. Image mode limits infrastructure drift by using well-established container tools and techniques.

**Immutable operating system**

In image mode, the root file system is immutable by default and application updates are atomic. The /etc and /var directories are designated to store mutable machine local data. The immutable design enhances stability and security.

**System definition committed to version control**

A Containerfile is now a simplified blueprint for the operating system, to include system configuration and application files. Bootable containers are built by using existing tools such as Podman.

**Better scalability**

Container images are fast to build and later updates are efficiently stored in additional image layers. An organization can maintain a handful of images and deploy them on many systems in large data center environments.

**Simplified troubleshooting**

System updates are atomic and are delivered in the form of updated container images that can be rolled back if needed.

---
#Creating Installable Images for Image Mode.
---

## The Containerfile Format

When using image mode for Red Hat Enterprise Linux, you deploy software, associated dependencies, and configuration files to hosts by using container images that conform to the Open Container Initiative (OCI) standard. Container images deliver operating system updates that can also be rolled back if necessary.

You can use existing and familiar tools such as Podman to build container images. A key piece of the build process is the Containerfile, which is widely used to create application containers and has the benefit of a standardized format.

![alt text](images/image28.png)

By adding a series of instructions to a Containerfile, you can customize an image to meet your needs. Each line in the Containerfile creates an image layer, which means that instructions are executed independently. During the build process, each instruction runs in an independent container by using an intermediate image built from the previous commands.

The following example Containerfile builds a typical application container:

```bash
# Use the ubi10 base image
FROM registry.redhat.io/ubi10 #1

# Install httpd
RUN dnf install -y httpd #2

# Copy a temporary index.html file to the web server root
COPY index.html /var/www/html/index.html #3

# Expose port 80 for httpd
EXPOSE 80 #4

# Set the entrypoint to run httpd in the foreground
ENTRYPOINT ["/usr/sbin/httpd", "-DFOREGROUND"] #5
```

1. The Red Hat Universal Base Image is the foundation for this application container.

2. The Apache HTTP service is layered on top of the base image.

3. The index.html file is copied from the project directory into the expected location in the container.

4. The `EXPOSE` instruction documents which port the service listens on at runtime. The HTTP port is TCP/80, which is defined in the standard Apache configuration file that ships in the httpd RPM package.

5. The `ENTRYPOINT` instruction defines the executable to run and any arguments to be passed to it when the container starts.

Although this sample Containerfile is sufficient for creating an application container, the approach to build a bootable container is somewhat different. Most importantly, the base image must be a specialized image that includes the required components for a full operating system, such as the kernel, a boot loader, and the systemd service manager. Red Hat provides the `rhel-bootc` base image, which incorporates tooling from the OSTree, `composefs`, and `bootc upstream` projects to enable image mode for RHEL.


<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Important:</b><br><br>
Red Hat Enterprise Linux in image mode and the rhel-bootc image are subject to the Red Hat Enterprise Linux end user license agreement (EULA). Therefore, you cannot publicly redistribute the base or any derivative user-created images.<br><br>
</div>

For example, the following Containerfile installs and enables the httpd package on top of the rhel-bootc image. Note the differences from the previous application container example.

```bash
# Use the rhel-bootc base image
FROM registry.redhat.io/rhel10/rhel-bootc:latest #1

# Install and enable httpd
RUN dnf -y install httpd mod_ssl && dnf clean all #2
RUN systemctl enable httpd && firewall-cmd --add-service=https #3

# Add httpd related files
ADD ./etc/ /etc #4
COPY ./index.html /var/www/html/index.html 
```

1. The `FROM` line directs Podman to use the rhel-bootc container image as a base.

2. The `RUN` lines execute the command sequence within the container, creating new image layers in the process.

3. Because the image is for RHEL in image mode, this Containerfile enables the httpd service instead of configuring an `ENTRYPOINT` or `CMD` instruction. Additionally, this Containerfile opens the firewall for HTTPS instead of using an `EXPOSE` instruction.

4. The `ADD` line includes a file or directory at the destination within the container. The `ADD` command can resolve files over the network or unpack files within an archive in addition to local files.

5. The `COPY` command copies a file or directory at a relative path to the destination location. The COPY command does not unpack files within an archive, and instead copies archive files directly into the container.

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Note:</b><br><br>
The Containerfile(5) manual page details the full specification for the Containerfile format. Many commands can take additional options and arguments, which you can use to significantly customize the resulting container image.<br><br>
</div>

Some `Containerfile` commands have no effect for RHEL in image mode:

- The `ENTRYPOINT` and `CMD` instructions are replaced by starting services via the systemd service manager.

- The `ENV` instruction is replaced by configuring the systemd service.

- The `EXPOSE` instruction is only for documenting application ports. In image mode, you can control access to ports by using firewall configuration.

- The `USER` instruction is replaced by runtime user management.

Although these commands do not affect a RHEL system in image mode, you can still use commands such as the `ENV` command to facilitate intermediate steps in a Containerfile. For example, you might decide to define a list of packages by using the `ENV` command, and then install those packages later by using a `RUN` command

## Building Bootable Container Images

You can use the `podman build` command to build a bootc image from the command line. Podman uses a Containerfile in the specified directory to build a container image. The `--squash` option merges all new layers into a single layer, which reduces the image's complexity and layer count.

```bash
podman build --squash -t \
registry.example.com/user/webserver-bootc:latest .
```

After building an image, you can push the image to an image repository by using the podman push command.

```bash
podman push registry.example.com/user/webserver-bootc:latest
```

## Testing a Bootable Image in Application Mode

To test a bootable container before deploying it, use the `podman run` command to launch the container locally. The following example starts the `registry.example.com/user/webserver` container image and forwards the `8080` port to port `80` in the container:

```bash
podman run -d -p 8080:80 registry.example.com/user/webserver
```

You can then verify that the container functions as you expect. In this case, you can verify that the web server is accessible on port 8080 by using the curl command.

```bash
curl http://localhost:8080
```

You can also validate functionality by viewing the running processes in the container with the podman exec command.

```bash
podman exec -l ps -ef
```

Notice that PID 1 is the init process. The init process is the systemd service manager, which started the httpd service.

When running a `bootc-based` container in application mode, the included RHEL kernel does not start. Processes run in the context of the container platform, which is podman in this example.

---
# Installing Red Hat Enterprise Linux by Using Image Mode
---

## Deploying a Bootable Container

A bootable container image includes the kernel, the boot loader, and other operating system components that are otherwise excluded from application containers. Although you can launch a container instance from the bootc image to test an application that is built into the image, ultimately a bootable container image must be deployed to a host that boots from it.

![alt text](images/image29.png)

When the contents of the image are installed on a physical or a virtual machine and the system boots up, the user space deployment itself does not run as a container. At this point, the container runtime that was used to build the image is no longer relevant. When the bootc tool is operating in deployed mode, the kernel that was installed from the image is executed during boot, and systemd runs as Process ID 1 to control all services, as is customary in Red Hat Enterprise Linux. The bootc tool is not a persistent daemon and does not impose any runtime overhead.

## Bare-metal Deployment by Using Anaconda Kickstart

To provision bare-metal servers, the recommended approach is to use the Anaconda installer's Kickstart feature, which supports image mode.

A Kickstart file helps to automate installation by providing answers to all the configuration options that the interactive installer would normally prompt the user for, such as storage configuration, user management, and package selection.

In general, all the standard commands and sections of a typical Kickstart file can be retained and used in image mode. The one notable exception is how software to be installed is specified. Traditionally, Anaconda is used in package mode and the `%packages` section in a Kickstart file is required to define software packages that you want to install:

```bash
%packages
@^minimal-environment
vim-enhanced
%end
```

To use Kickstart in image mode, you must remove the `%packages` section and replace it with the `ostreecontainer` command, to indicate the registry and the bootable container to deploy on the target system. The container image must be derived from the official rhel-bootc base image.

```bash
ostreecontainer --url=registry.lab.example.com:5000/student/webserver-bootc
```

This command is a reference to the `libostree` project, which `bootc` currently depends on for storing the base container image. The use of OSTree is a design choice, and its role might decrease in the future.

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Note:</b><br><br>
The direct use of the rpm-ostree command to make system changes or to install content is not supported.<br><br>
</div>

The RHEL `bootc` image is generic and does not include any configuration such as a default user account. To create user accounts and set passwords or to inject SSH public keys, you can use standard Kickstart commands. The following example sets the root password and creates a user account with administrator privileges:

```bash
rootpw --iscrypted $6$KUnFfrTzO8jv.PiH$YlBbOtXBkWzoMuRfb0.SpbQ....XDR1UuchoMG1
user --name=student --groups=wheel --iscrypted --password=$6$JJlPUjtsQ....F2co
```

After you successfully adjust your Kickstart file for use in image mode, you can publish the file to make it available in your environment. The most popular choice is to copy the file to a web server that can be accessed on the local network.

To start the Anaconda installer on a target system, you can choose from several methods. You might set up PXE services for network booting as a more advanced solution, or copy the RHEL binary installation ISO to a USB drive to boot the new machine manually. In either case, when the Anaconda boot menu starts on the target system, the `inst.ks=URL` argument must be provided on the kernel command line to inform the installer where the Kickstart file is located.

If the Kickstart file is not referenced correctly, then Anaconda starts the normal graphical user interface, which does not support image mode currently.

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Note:</b><br><br>
For more information about how to use Kickstart, refer to  Automatically Installing Red Hat Enterprise Linux. https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/10/html-single/automatically_installing_rhel/index <br><br>
</div>

## Generating Disk Images for Hybrid Cloud Environments

Portability is an important factor when using Red Hat Enterprise Linux in image mode. In addition to bare-metal systems, the bootc images can also be deployed to machines in virtualized, cloud, and edge environments. This process involves converting a bootc image to one of the native disk formats.

The `bootc-image-builder` tool is available to generate disk images from the `bootc` image for various platforms:

| **Image format** | **Target environment**        |
|------------------:|:------------------------------|
| qcow2 (default)  | QEMU                          |
| vmdk             | VMware vSphere                |
| vhd              | Microsoft Virtual PC           |
| ami              | Amazon Machine Image           |
| gcd              | Google Compute Engine          |
| raw              | Unformatted raw disk           |


To get started with the `bootc-image-builder` tool, you must first download its container image from the Red Hat Ecosystem Catalog. This tool is intended for use as a container and it is not available as an RPM package in RHEL.

The following steps show how to use the podman command to get the necessary container image. The `sudo` command is used for privilege escalation because the `bootc-image-builder` tool must run as a `root` container when it is launched to generate disk images.

1. Authenticate to the registry:

```bash
sudo podman login registry.redhat.io
```

2. Download the bootc-image-builder container image:

```bash
sudo podman pull registry.redhat.io/rhel10/bootc-image-builder
```

## Creating a QCOW2 Disk Image

The default disk image format that the bootc-image-builder tool generates is QCOW2. This disk format can be used to deploy virtual machines that run on Kernel-based Virtual Machine (KVM) hypervisors.

Red Hat Enterprise Linux provides virtualization functions by using KVM. Virtualization capabilities are further expanded in the OpenShift Virtualization and Red Hat OpenStack Platform products.

The following example shows how to generate a QCOW2 disk image from a custom bootable container image that is derived from the official rhel-bootc base image.

The RHEL `bootc` base image is generic and contains no user accounts. The recommended approach to create users is to supply a customization file to the `bootc-image-builder` tool with the necessary user information. Create the `config.toml` file in your project directory to define users with content similar to the following example:

```bash
[[customizations.user]]
name = "user1"
password = "password1"
groups = ["wheel"]

[[customizations.user]]
name = "user2"
password = "password2"
groups = ["wheel"]
```

This example build configuration file is in the TOML data format; JSON is also supported.

During image build, the file must be mapped into the container by using the `/config.toml` path.

As another prerequisite, create a directory inside the project that binds to the output directory inside the container, where the `bootc-image-builder` tool writes the `qcow2` disk image.

```bash
mkdir output
```

To start the build process, run the `bootc-image-builder` container by using the following arguments:

```bash
sudo podman run \
--rm \
-it \
--privileged \ #1
--security-opt label=type:unconfined_t \
-v ./config.toml:/config.toml \  #2
-v ./output:/output \ #3
registry.redhat.io/rhel10/bootc-image-builder \
--type qcow2 \ #4
registry.lab.example.com/user/bootc-httpd:latest #5
```

1. This container must run with root privileges.
2. The customization file to create user accounts is mounted into the bootc-image-builder container by using the expected /config.toml path.
3. The output directory in the current working directory is mounted into the container by using the expected /output path.
4. Specify the disk image type.
5. Refer to the customized bootable container image to convert to a disk image.

## Deploying a New Virtual Machine on KVM

To test the new disk image, copy it to the file-system location where RHEL hypervisors expect to store images by default:

```bash
sudo cp output/qcow2/disk.qcow2 /var/lib/libvirt/images/
```

Then, create a virtual machine by using the `virt-install` command. The following example defines a minimal set of settings to create the machine and to import the disk that the `bootc-image-builder` container generated

```bash
sudo virt-install \
--name bootc-webserver \
--memory 4096 \
--import --disk /var/lib/libvirt/images/disk.qcow2 \
--graphics none \
--osinfo rhel10.0 \
--noautoconsole \
--noreboot
```

After successfully defining the new virtual machine, you can start it by using the `virsh` command.

```bash
sudo virsh start bootc-webserver
```
---
# Installing Red Hat Enterprise Linux by Using Image Mode
---

## Deploying a Bootable Container

A bootable container image includes the kernel, the boot loader, and other operating system components that are otherwise excluded from application containers. Although you can launch a container instance from the `bootc` image to test an application that is built into the image, ultimately a bootable container image must be deployed to a host that boots from it.

![alt text](images/image30.png)

When the contents of the image are installed on a physical or a virtual machine and the system boots up, the user space deployment itself does not run as a container. At this point, the container runtime that was used to build the image is no longer relevant. When the `bootc` tool is operating in deployed mode, the kernel that was installed from the image is executed during boot, and systemd runs as Process ID 1 to control all services, as is customary in Red Hat Enterprise Linux. The bootc tool is not a persistent daemon and does not impose any runtime overhead.

## Bare-metal Deployment by Using Anaconda Kickstart

To provision bare-metal servers, the recommended approach is to use the Anaconda installer's Kickstart feature, which supports image mode.

A Kickstart file helps to automate installation by providing answers to all the configuration options that the interactive installer would normally prompt the user for, such as storage configuration, user management, and package selection.

In general, all the standard commands and sections of a typical Kickstart file can be retained and used in image mode. The one notable exception is how software to be installed is specified. Traditionally, Anaconda is used in package mode and the %packages section in a Kickstart file is required to define software packages that you want to install:

```bash
%packages
@^minimal-environment
vim-enhanced
%end
```

To use Kickstart in image mode, you must remove the `%packages` section and replace it with the `ostreecontainer` command, to indicate the registry and the bootable container to deploy on the target system. The container image must be derived from the official rhel-bootc base image.

```bash
ostreecontainer --url=registry.lab.example.com:5000/student/webserver-bootc
```

This command is a reference to the `libostree` project, which bootc currently depends on for storing the base container image. The use of OSTree is a design choice, and its role might decrease in the future.

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Note:</b><br><br>
The direct use of the rpm-ostree command to make system changes or to install content is not supported.<br><br>
</div>

The RHEL `bootc` image is generic and does not include any configuration such as a default user account. To create user accounts and set passwords or to inject SSH public keys, you can use standard Kickstart commands. The following example sets the root password and creates a user account with administrator privileges:

```bash
rootpw --iscrypted $6$KUnFfrTzO8jv.PiH$YlBbOtXBkWzoMuRfb0.SpbQ....XDR1UuchoMG1
user --name=student --groups=wheel --iscrypted --password=$6$JJlPUjtsQ....F2co
```

After you successfully adjust your Kickstart file for use in image mode, you can publish the file to make it available in your environment. The most popular choice is to copy the file to a web server that can be accessed on the local network.

To start the Anaconda installer on a target system, you can choose from several methods. You might set up PXE services for network booting as a more advanced solution, or copy the RHEL binary installation ISO to a USB drive to boot the new machine manually. In either case, when the Anaconda boot menu starts on the target system, the `inst.ks=URL` argument must be provided on the kernel command line to inform the installer where the Kickstart file is located.

If the Kickstart file is not referenced correctly, then Anaconda starts the normal graphical user interface, which does not support image mode currently.

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Note:</b><br><br>
For more information about how to use Kickstart, refer to Automatically Installing Red Hat Enterprise Linux.automatically_installing_rhel/index
<br><br>

https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/10/html-single/automatically_installing_rhel/index
<br><br>
</div>

## Generating Disk Images for Hybrid Cloud Environments

Portability is an important factor when using Red Hat Enterprise Linux in image mode. In addition to bare-metal systems, the `bootc` images can also be deployed to machines in virtualized, cloud, and edge environments. This process involves converting a bootc image to one of the native disk formats.

The bootc-image-builder tool is available to generate disk images from the bootc image for various platforms:

| **Image Format** | **Target Environment**      |
|------------------|-----------------------------|
| qcow2 (default)  | QEMU                        |
| vmdk             | VMware vSphere              |
| vhd              | Microsoft Virtual PC        |
| ami              | Amazon Machine Image (AMI)  |
| gcd              | Google Compute Engine       |
| raw              | Unformatted raw disk        |

To get started with the `bootc-image-builder` tool, you must first download its container image from the Red Hat Ecosystem Catalog. This tool is intended for use as a container and it is not available as an RPM package in RHEL.

The following steps show how to use the podman command to get the necessary container image. The `sudo` command is used for privilege escalation because the bootc-image-builder tool must run as a root container when it is launched to generate disk images.

1. Authenticate to the registry:

```bash
sudo podman login registry.redhat.io
```

2. Download the `bootc-image-builder` container image:

```bash
sudo podman pull registry.redhat.io/rhel10/bootc-image-builder
```

## Creating a QCOW2 Disk Image

The default disk image format that the `bootc-image-builder` tool generates is `QCOW2`. This disk format can be used to deploy virtual machines that run on Kernel-based Virtual Machine (KVM) hypervisors.

Red Hat Enterprise Linux provides virtualization functions by using KVM. Virtualization capabilities are further expanded in the OpenShift Virtualization and Red Hat OpenStack Platform products.

The following example shows how to generate a `QCOW2` disk image from a custom bootable container image that is derived from the official rhel-bootc base image.

The RHEL bootc base image is generic and contains no user accounts. The recommended approach to create users is to supply a customization file to the `bootc-image-builder` tool with the necessary user information. Create the `config.toml` file in your project directory to define users with content similar to the following example:

```bash
[[customizations.user]]
name = "user1"
password = "password1"
groups = ["wheel"]

[[customizations.user]]
name = "user2"
password = "password2"
groups = ["wheel"]
```

This example build configuration file is in the TOML data format; JSON is also supported.

During image build, the file must be mapped into the container by using the `/config.toml` path.

As another prerequisite, create a directory inside the project that binds to the output directory inside the container, where the `bootc-image-builder` tool writes the `qcow2` disk image.

```bash
mkdir output
```

To start the build process, run the `bootc-image-builder` container by using the following arguments:

```bash
sudo podman run \
--rm \
-it \
--privileged \ #1
--security-opt label=type:unconfined_t \
-v ./config.toml:/config.toml \  #2
-v ./output:/output \ #3
registry.redhat.io/rhel10/bootc-image-builder \
--type qcow2 \ #4
registry.lab.example.com/user/bootc-httpd:latest 5
...output omitted...
```

1. This container must run with root privileges.
2. The customization file to create user accounts is mounted into the `bootc-image-builder` container by using the expected `/config.toml` path.
3. The output directory in the current working directory is mounted into the container by using the expected /output path.
4. Specify the disk image type.
5. Refer to the customized bootable container image to convert to a disk image.

## Deploying a New Virtual Machine on KVM

To test the new disk image, copy it to the `file-system` location where RHEL hypervisors expect to store images by default:

```bash
sudo cp output/qcow2/disk.qcow2 /var/lib/libvirt/images/
```

Then, create a virtual machine by using the `virt-install` command. The following example defines a minimal set of settings to create the machine and to import the disk that the `bootc-image-builder` container generated.

```bash
sudo virt-install \
--name bootc-webserver \
--memory 4096 \
--import --disk /var/lib/libvirt/images/disk.qcow2 \
--graphics none \
--osinfo rhel10.0 \
--noautoconsole \
--noreboot
...output omitted...
```
After successfully defining the new virtual machine, you can start it by using the virsh command.

```bash
sudo virsh start bootc-webserver
```

---
# Managing Image Mode-based Systems
---

## Image Mode Day 2 Operations

Day 2 operations refers to the ongoing management tasks on a system after it is deployed. These tasks cover the bulk of the work to do on a system during its lifetime.

After you build and deploy the `bootc` image to a target system, you can perform Day 2 operations by fetching updates and applying them. These operations consist of transactional updates from a container registry; they are layered, are installed in-place, and can be rolled back if necessary.

![alt text](images/image31.png)

## Verifying the Current System State

You can check the current status of the system by using the `bootc status` command. It displays whether a new image is staged for update, the current booted image in the system, and the rollback image that is set, if any. A newly installed system does not show any staged or rollback images.

```bash
bootc status
```

```yaml
apiVersion: org.containers.bootc/v1
kind: BootcHost
metadata:
  name: host
spec:
  image:
    image: registry.lab.example.com/user/example-bootc
    transport: registry
  bootOrder: default
status:
  staged: null
  booted:
    image:
      image:
        image: registry.lab.example.com/user/example-bootc
        transport: registry
      version: 10.20250116.0
      timestamp: null
      imageDigest: sha256:87b02be441cda3d66c9c...71b092ce7b2311e2defbb93f
    cachedUpdate: null
    incompatible: false
    pinned: false
    store: ostreeContainer
    ostree:
      checksum: 9981913741c37dbb6400...3b68479d2c33b6f5434aa338
      deploySerial: 0
  rollback: null
  rollbackQueued: false
  type: bootcHost
```

## Upgrading the System

Red Hat Enterprise Linux needs to be installed in image mode only once on a system. After the system is installed, you must make all subsequent changes and updates by performing the following steps:

1. Edit the Containerfile in the bootc image project directory.
2. Rebuild the container image.
3. Push the new container image to the registry with the same name tag.
4. Update the image on the system by using the bootc command.
5. Reboot the system to apply the changes.

When using image mode for RHEL, automatic updates are enabled by default. The `bootc-fetch-apply-updates` systemd service and the timer unit files check the container registry for updates regularly and apply them to the system.

```bash
systemctl status bootc-fetch-apply-updates.timer
```

However, you can choose to update your systems manually. You might update manually when applying nontrivial updates. Turning off the `bootc` automatic updates might also be necessary if you use automated processes for updating, for example by using Ansible.

To turn off automatic updates permanently, you can disable the timer unit that checks for image updates.

```bash
systemctl mask bootc-fetch-apply-updates.timer
```

To manually fetch updates from a registry and to boot into the new deployment, use the `bootc upgrade` command. This command fetches the transactional in-place updates from the container image registry to the installed operating system. The command queries the registry, downloads the updated image layers, and configures the new deployment for use during the next boot. When the updated base image is staged this way, the running system remains unaffected. A reboot is always required to apply the changes.

```bash
bootc upgrade
```

You can use the `--apply` option to automatically reboot the system when a staged image is present. Use the --check option to see image updates without applying them.

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Note:</b><br><br>
The bootc upgrade and bootc update commands are aliases.
<br><br>
</div>

## File-system Analysis in Image Mode

In image mode systems, the file-system layout is similar to a traditional installation in that directories such as `/home`, `/etc`, `/var`, and `/usr` still store the types of data that you would expect. However, these locations are used differently in image mode. They use a combination of inmutable and mutable volumes to keep consistency, avoid drift, and still enable data persistence.

## The Root File System

Image mode for RHEL `uses composefs` for the root file system by default. Composefs is an overlay file system that enables a truly read-only root file system. The data comes from one of the OSTree deployments in the `/ostree/repo` directory. OSTree can store multiple file systems in parallel in its repository, which enables deploying a new file-system image without deleting the earlier version. This model is similar to source code version control, but for entire file-system objects instead of individual files. Combining Composefs with an OSTree-based system improves both performance and file-system integrity.

```bash
df -h
```

```bash
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda3       9.0G  1.9G  7.2G  21% /sysroot
composefs       8.4M  8.4M     0 100% /  ##### 
devtmpfs        4.0M     0  4.0M   0% /dev
tmpfs           983M     0  983M   0% /dev/shm
tmpfs           394M  488K  393M   1% /run
tmpfs           983M     0  983M   0% /tmp
tmpfs           1.0M     0  1.0M   0% /run/credentials/systemd-journald.service
/dev/sda2       960M  153M  808M  16% /boot
tmpfs           1.0M     0  1.0M   0% /run/credentials/getty@tty1.service
tmpfs           197M  4.0K  197M   1% /run/user/1000
```

## The `/etc` and `/var` Directories

The `/etc` and `/var` system directories are mutable and persistent by default, and they work differently.

For the `/etc` directory, the bootc image performs a 3-way merge during upgrades.

Each file-system tree that you deploy from the `bootc` image has its own copy of the `/etc` directory. Your local changes in the `/etc` directory of the currently booted deployment are retained and propagated across all future upgrades. On the other hand, unmodified files in the `/etc` directory get updated if a new bootc image provides later versions of the same files.

The `ostree-finalize-staged.service` unit executes these tasks during shutdown, and creates a boot-loader entry for the new deployment.

The `/var` directory is shared between the various file-system deployments that are installed on the system. This directory is not merged during upgrades.

By default, the contents of the `/var` directory are copied from the container image during the initial installation but are not updated afterwards. During later upgrades, existing files are not changed or deleted, even if the Containerfile includes explicit instructions to do so. When you roll back by using the `bootc` command, the contents of the `/var` directory are not rolled back.

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Note:</b><br><br>
You cannot push changes to content in the /var directory by using image upgrades or rollbacks.
<br><br>
</div>

## Version Selection and Bootup

Image mode for RHEL uses GRUB2 (GRand Unified Bootloader version 2) by default except for the s390x architectures. Each OSTree deployment that is currently available on a system has its own menu entry.

The GRUB2 boot loader uses these entries to present an interactive menu during system bootup. Within menu entries, kernel arguments determine which OSTree deployment to use for the root file system. This mechanism enables booting into previous deployments if a particular upgrade caused problems.

![alt text](images/image32.png)

## Rolling Back a System

You can use the `bootc rollback` command to revert the system to a previous available image version. When the command is executed, the deployment under the `rollback` option is queued for the next boot, and the current version becomes the new rollback. The GRUB2 menu gets updated to show the previous deployment as the first entry. Finally, if a `staged` entry exists, it is discarded.

```bash
bootc rollback
```

