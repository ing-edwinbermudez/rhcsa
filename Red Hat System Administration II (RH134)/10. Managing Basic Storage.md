# Creating and Managing File Systems on Standard Partitions
---

## Disk Partitioning

Disk partitioning divides a hard drive into multiple logical storage partitions. You can use partitions to divide storage based on different requirements, and this division provides many benefits:

- Limit available space to applications or users.
- Separate operating system and program files from user files.
- Create a separate area for memory swapping.
- Limit disk space use to improve the performance of diagnostic tools and backup imaging.

On x86 systems, the two primary partitioning schemes are Master Boot Record (MBR) and GUID Partition Table (GPT).

### Master Boot Record (MBR) Partition Scheme

The Master Boot Record (MBR) partitioning scheme is the standard on systems that run Basic Input/Output System (BIOS) firmware. This scheme supports a maximum of four primary partitions. On Linux systems, with extended and logical partitions, you can create up to 15 partitions. With a 32-bit partition size, disks that are partitioned with MBR can have a size of up to 2 TiB.

![alt text](images/image7.png)

MBR partitioning of the `/dev/sdb` storage device

The 2 TiB disk and partition size limit is now a common and restrictive limitation. Consequently, the legacy MBR scheme is superseded by the GUID Partition Table (GPT) partitioning scheme.

### GUID Partition Table (GPT) Partition Scheme

For systems that run Unified Extensible Firmware Interface (UEFI) firmware, the GUID Partition Scheme (GPT) is the standard for disk partitioning, and addresses the limitations of the MBR scheme. The GPT scheme provides a maximum of 128 partitions. The GPT scheme allocates 64 bits for logical block addresses to support partitions and disks of up to eight zebibytes (ZiB) or eight billion tebibytes (TiB).

## Managing Partitions

An administrator can use a partition editor program to change a disk's partitions, such as by creating and deleting partitions, and changing partition types.

Red Hat Enterprise Linux provides the `parted` command as the standard command-line partition editor. You can use the parted partition editor with storage that uses either the MBR partitioning scheme or the GPT partitioning scheme.

The `parted` command takes as its first argument the device name that represents the entire storage device or disk to modify, followed by subcommands.

The following example uses the print subcommand to display the partition table on the disk that is the `/dev/sda` block device (the first QEMU disk that the system detects):

```bash
parted /dev/sda print
```

To start an interactive session, execute the `parted` command as 
the `root` user and specify the disk device name as an argument:

```bash
parted /dev/sda
```

Use the `print` subcommand to display the partition table:

```bash
print
```

To exit the interactive partitioning session, use the quit command:

```bash
quit
```


By default, the parted command displays sizes in powers of 10 (KB, MB, GB). You can change the unit size with the unit parameter, which accepts the following values:

- s for sector
- B for byte
- MiB, GiB, or TiB (powers of 2)
- MB, GB, or TB (powers of 10)

The following example shows the partition table for the /dev/sda device in sectors:

```bash
parted /dev/sda unit s print
```
You can specify multiple subcommands on the same line, such as the unit and print subcommands in the previous example.

## Write the Partition Table on a New Disk

To partition a new drive, first write a disk label. The disk label indicates which partitioning scheme to use.

Use the `parted` command to write an MBR disk label:

```bash
parted /dev/sdb mklabel msdos
```

Use the `parted` command to write a GPT disk label:

```bash
parted /dev/sdb mklabel gpt
```

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Warning:</b><br><br>
The mklabel subcommand wipes the existing partition table. Use the mklabel subcommand to reuse the disk without regard to the existing data. If a new label moves the partition boundaries, then all data in existing file systems becomes inaccessible.<br><br>
</div>

## Create MBR Partitions

The following instructions create an MBR disk partition. Specify the disk device to create the partition on.

To start an interactive session, run the parted command as the root user and specify the disk device name as an argument:

```bash
parted /dev/sdb
```

Use the `mkpart` subcommand to create a partition. The help mkpart subcommand displays the syntax and available options for each argument:

```bash
help mkpart
```
```bash
 mkpart PART-TYPE [FS-TYPE] START END     make a partition

        PART-TYPE is one of: primary, logical, extended
        FS-TYPE is one of: udf, btrfs, nilfs2, ext4, ext3, ext2, f2fs, fat32, fat16,
        hfsx, hfs+, hfs, jfs, swsusp, linux-swap(v1), linux-swap(v0), ntfs, reiserfs,
        hp-ufs, sun-ufs, xfs, apfs2, apfs1, asfs, amufs5, amufs4, amufs3, amufs2,
        amufs1, amufs0, amufs, affs7, affs6, affs5, affs4, affs3, affs2, affs1, affs0,
        linux-swap, linux-swap(new), linux-swap(old)
        START and END are disk locations, such as 4GB or 10%.  Negative values count
        from the end of the disk.  For example, -1s specifies exactly the last sector.

        'mkpart' makes a partition without creating a new file system on the partition.
        FS-TYPE may be specified to set an appropriate partition ID.
```

Create a primary or extended partition.

```bash
(parted) mkpart
Partition type?  primary/extended? primary
```

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Note:</b><br><br>
If you require more than four partitions on an MBR-partitioned disk, then create three primary partitions and one extended partition. The extended partition serves as a container within which you can create multiple logical partitions.<br><br>
</div>

Next, you are prompted to enter the label for the file-system type. To list the supported file-system types, press Tab twice:

```bash
File system type?  [ext2]? Tab Tab
affs0  affs4  amufs  amufs3  apfs2  ext3  fat32  hp-ufs  linux-swap(old)  ntfs  udf
affs1  affs5  amufs0  amufs4  asfs  ext4  hfs  jfs  linux-swap(v0)  reiserfs  xfs
affs2  affs6  amufs1  amufs5  btrfs  f2fs  hfs+  linux-swap  linux-swap(v1)  sun-ufs
affs3  affs7  amufs2  apfs1   ext2   fat16  hfsx  linux-swap(new)  nilfs2  swsusp
```

Enter the file-system type to use on the partition, such as xfs or ext4. This value is only used as a partition type label, and does not create the file system.

```bash
File system type?  [ext2]? xfs
```

Specify the disk sector where the partition starts.

```bash
Start? 2048s
```

The `s` suffix provides the value in sectors, or you can use the MiB, GiB, TiB, MB, GB, or TB suffixes. The parted command defaults to the MB suffix. The parted command rounds provided values to satisfy disk constraints.

When the parted command starts, it retrieves the disk topology from the device, such as the disk's physical block size. The parted command ensures that the start position that you provide correctly aligns the partition with the disk structure, to optimize performance. If the start position results in a misaligned partition, then the parted command displays a warning. With most disks, a start sector that is a multiple of 2048 is safe.

Specify the disk sector where the partition ends. You can specify the end as a size or as an ending location. When you provide the end position, the `parted` command updates the partition table on the disk with the new partition details.

```bash
End? 1000MB
```

Exit the `parted` command:

```bash
(parted) quit
Information: You may need to update /etc/fstab.

root@host:~#
```

After creating the partition, run the `udevadm` command for the system to detect the new partition and to create the associated device file in the `/dev` directory.

```bash
udevadm settle
```

As an alternative to using interactive mode, you can create a partition in a single, noninteractive command:

```bash
parted /dev/sdb mkpart primary xfs 2048s 1000MB
```

## Create GPT Partitions

The GPT scheme also uses the parted command to create partitions. Specify the disk device to create the partition on.

To start an interactive session, execute the `parted` command as the root user and specify the disk device name as an argument:

```bash
parted /dev/sdb
```

Use the `mkpart` subcommand to begin creating the partition. With the GPT scheme, each partition is given a name.

```bash
(parted) mkpart
Partition name?  []? userdata
```

Enter the file-system type to use on the partition, such as xfs or ext4. This value is only used as a partition type label, and does not create the file system.

```bash
File system type?  [ext2]? xfs
```

Specify the disk sector where the partition starts:

```bash
Start? 2048s
```

Specify the disk sector where the partition ends. When you provide the end position, the `parted` command updates the GPT partition on the disk with the new partition details.

```bash
End? 1000MB
```

Exit the parted command.

```bash
(parted) quit
Information: You may need to update /etc/fstab.
```

Run the `udevadm` settle command. This command waits for the system to detect the new partition and to create the associated device file in the `/dev` directory.

```bash
udevadm settle
```

As an alternative to using interactive mode, you can create a partition in a single command:

```bash
parted /dev/sdb mkpart userdata xfs 2048s 1000MB
```

## Deleting Partitions

The following instructions apply for both the MBR and GPT partitioning schemes. Specify the disk that contains the partition to remove.

Run the `parted` command with the disk device as the only argument:

```bash
parted /dev/sdb
```

Identify the partition number of the partition to delete:

```bash
(parted) print
```

Delete the partition. The rm subcommand immediately deletes the partition from the partition table on the disk.

```bash
rm 1
```

Exit the parted command:

```bash
quit
```

As an alternative to using interactive mode, you can delete a partition in a single command:

```bash
parted /dev/sdb rm 1
```

## Creating File Systems

After the partitioning tool creates the partition as a new block device, the next step is to add a file system to it. Red Hat Enterprise Linux supports multiple file-system types, and XFS is the recommended default.

As the `root` user, use the `mkfs.xfs` command to format the partition with the XFS file system:


```bash
mkfs.xfs /dev/sdb1
```

To add an ext4 file system, use the `mkfs.ext4` command.

## Mounting File Systems

After you add the file system, the last step is to mount the file system to a directory in the directory structure. When you mount a file system to the directory hierarchy, user-space utilities can access or write files on the device.

## Manually Mount File Systems

Use the `mount` command to manually attach a device to a mount point directory location.

The `mount` command requires a device and a mount point, and can include file-system mount options. File-system options customize the behavior of the file system.

```bash
mount /dev/sdb1 /mnt
```

You also use the `mount` command to view currently mounted file systems, the mount points, and their options. To display the output of the mount command, do not provide a trailing slash with the partition.


```bash
mount | grep sdb1
```

## Persistently Mount File Systems

Manually mounting a file system is a good way to verify that a formatted device is accessible and is working as expected. However, when the server reboots, the system does not automatically mount the file system again.

To configure the system to automatically mount the file system during system boot, add an entry to the `/etc/fstab` file. This configuration file lists the file systems to mount at system boot.

The `/etc/fstab` file is a whitespace-delimited file with six fields per line.

```bash
cat /etc/fstab

UUID=a8063676-44dd-409a-b584-68be2c9f5570   /        xfs   defaults   0 0
UUID=7a20315d-ed8b-4e75-a5b6-24ff9e1f9838   /dbdata  xfs   defaults   0 0
```

The first field specifies the device. This example uses a UUID to specify the device. File systems create and store the UUID in the partition super block at creation time. Alternatively, you could use the device file, such as `/dev/sdb1`.

The second field is the mount point, which is the specified directory where the block device is accessible. The mount point must exist; if not, then create it with the `mkdir` command.

The third field displays the file-system type, such as `xfs` or `ext4`.

The fourth field is the comma-separated list of options to apply to the device. The `defaults` option is a set of commonly used options. The `mount(8)` man page documents the other available options.

The fifth field is used by the `dump` command to back up the device. Other backup applications do not usually use this field.

The last field, the `fsck` order field, determines whether to run the `fsck` command at system boot to verify that the file systems are clean. The value in this field indicates the order in which the `fsck` command must run. For XFS file systems, set this field to 0, because XFS does not use the fsck command to verify its file-system status. For ext4 file systems, set it to 1 for the root file system, and to 2 for the other ext4 file systems. By using this notation, the fsck command processes the root file system first, and then verifies file systems on separate disks concurrently, and file systems on the same disk in sequence.

<div style="border: 1px solid #aaa; border-radius: 6px; padding: 12px; background: #020202ff;">
<b>Note:</b><br><br>
An incorrect entry in the /etc/fstab file might render the machine nonbootable. Verify that an entry is valid by manually unmounting the new file system and then by using the mount command to read the /etc/fstab file, and remount the file system with that entry's mount options. If the mount command returns an error, then correct it before rebooting the machine.<br><br>

Alternatively, use the findmnt command --verify option to parse the /etc/fstab file for partition usability.<br><br>
</div>

When you add or remove an entry in the `/etc/fstab` file, run the `systemctl daemon-reload` command, or reboot the server, to ensure that the systemd daemon loads and uses the new configuration.

```bash
systemctl daemon-reload
```

Red Hat recommends the use of UUIDs to persistently mount file systems. Block device names can change in certain scenarios, such as if a cloud provider changes the underlying storage layer of a virtual machine, or if disks are detected in a different order on a system boot. The block device file name might change, but the UUID remains constant in the file system's super block.

Use the `lsblk` command `--fs` option to scan the block devices that are connected to a machine and to retrieve the file-system UUIDs.

```bash
lsblk --fs
```

