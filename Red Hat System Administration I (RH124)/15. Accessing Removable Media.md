# Accessing Removable Media

## File Systems and Storage Devices

Red Hat Enterprise Linux (RHEL) uses the Extents File System (XFS) as the default local file system. RHEL supports the Extended File System (ext4) file system for managing local files. Starting with RHEL 10, the Extensible File Allocation Table (exFAT) file system is supported for removable media use

## Mounting File Systems
Access the contents of a file system by mounting it on an empty directory. This directory is called a mount point. When the directory is mounted, use the ls command to list its contents. Many file systems are automatically mounted when the system boots.

A mount point differs slightly from a Microsoft Windows drive letter, where each file system is a separate entity. Mount points enable multiple file-system devices to be available in a single tree structure. This mount point is similar to NTFS mounted folders in Microsoft Windows.

## Using Block Devices

A block device is a file that provides low-level access to storage devices. A block device representing a hard disk drive or solid-state device (SSD) is usually partitioned into several smaller block devices, and a partition must be formatted with a file system before its file system can be mounted.

The `/dev` directory stores block device files, which RHEL creates automatically for all devices. In RHEL systems, the first detected Serial ATA (SATA), Serial Attached SCSI (SAS), SCSI, or USB hard drive is called the `/dev/sda` device; the second is the `/dev/sdb` device; and so on. These names represent the entire hard drive.

### Table 14.1. Block Device Naming

| Type of device                                      | Device naming pattern                      |
| --------------------------------------------------- | ------------------------------------------- |
| SATA/SAS/USB-attached storage (SCSI driver)         | `/dev/sda`, `/dev/sdb`, `/dev/sdc`, …       |
| virtio-blk paravirtualized storage (VMs)            | `/dev/vda`, `/dev/vdb`, `/dev/vdc`, …       |
| virtio-scsi paravirtualized storage (VMs)           | `/dev/sda`, `/dev/sdb`, `/dev/sdc`, …       |
| NVMe-attached storage (SSDs)                        | `/dev/nvme0`, `/dev/nvme1`, …               |
| SD/MMC/eMMC storage (SD cards)                      | `/dev/mmcblk0`, `/dev/mmcblk1`, …           |


## Disk Partitions

Usually, a storage device is divided into multiple partitions.

With partitions, you can compartmentalize a disk: the various partitions might be formatted with different file systems or be used for other purposes. For example, one partition might contain user home directories, whereas another partition might contain system data and logs. Even when the home directory partition is loaded with data, the system partition might still have available space.

Partitions are block devices in their own right. For example, on the first SATA-attached storage, the first partition is the `/dev/sda1` disk. The second partition of the same storage is the `/dev/sda2` disk. The third partition on the third SATA-attached storage device is the `/dev/sdc3` disk, and so on. Paravirtualized storage devices have a similar naming system. For example, the first partition on the first storage device is the `/dev/vda1` disk. The second partition of the second storage device is the /dev/vdb2 disk, and so on.

An NVMe-attached SSD device names its partitions differently from a SATA-attached device. For NVMe storage devices, the `nvmeX` part of the name refers to the device; the `nY` part refers to the namespace; and the `pZ` part refers to the partition. For example, the first partition for the first namespace on the first disk is the `/dev/nvme0n1p1` partition. The third partition for the first namespace on the second disk is the /dev/nvme1n1p3 partition, and so on.

MultiMediaCard (MMC) or Secure Digital (SD) cards can sometimes have a similar naming system to the SATA devices (/dev/sdN). In some cases, SD or MMC cards might have names such as `/dev/mmcblk0p1`, where the `mmcblkX` part of the name refers to the storage device, and the pY part of the name refers to the partition number on that device.

An extended listing of the /dev/sda1 device file on the host machine reveals the b file type, which stands for a block device:

```bash
ls -l /dev/sda1
```

## Logical Volumes

Another way to organize disks and partitions is with Logical Volume Management (LVM). LVM aggregates block devices into a volume group. Disk space in the volume group is separated into logical volumes, which are the functional equivalent of a partition on a physical disk.

The LVM system assigns names to volume groups and logical volumes on their creation. LVM creates a directory in the `/dev` directory that matches the group name, and creates a symbolic link within that new directory with the same name as the logical volume. That logical volume file is then available to be mounted. For example, when a myvg volume group and the mylv logical volume are present, the full path to the logical volume is the `/dev/myvg/mylv` file.

**Note** The previously mentioned logical volume device name establishes a symbolic link to the device file that accesses it, which might vary between boots. Another form of the logical volume device name, which is linked from files in the /dev/mapper directory, is often used for symbolic links to the device file.

## Examine File Systems

Use the `df` command to display an overview of local and remote file-system devices, which includes the total disk space, used disk space, free disk space, and the percentage of the entire disk space.

The following example displays the file systems and mount points on the host machine:

```bash
df
```

```bash
Filesystem  1K-blocks    Used Available Use% Mounted on
/dev/sda3    10213356 2458040   7755316  25% /
devtmpfs         4096       0      4096   0% /dev
tmpfs          873064       0    873064   0% /dev/shm
tmpfs          349228   10784    338444   4% /run
tmpfs            1024       0      1024   0% /run/credentials/systemd-journald...
/dev/sda2      204580    8580    196000   5% /boot/efi
tmpfs            1024       0      1024   0% /run/credentials/getty@tty1...
tmpfs            1024       0      1024   0% /run/credentials/serial-getty@...
tmpfs          174612       4    174608   1% /run/user/1000
```

The partitioning shows that two physical file systems are mounted on the root (`/`) and `/boot/efi` directories that commonly exist on virtual machines. The `tmpfs` and `devtmpfs` devices are file systems in system memory. All files that are written to the tmpfs or devtmpfs file systems disappear after a system reboot.

The df command `-h` or `-H` options are human-readable options to improve the readability of the output sizes. The `-h` option reports in KiB (210), MiB (220), or GiB (230), whereas the -H option reports in SI units: KB (103), MB (106), or GB (109). Hard drive manufacturers usually use SI units when advertising their products.

View the file systems on the host machine with all units converted to human-readable format:

```bash
df -h
```

Use the `du` command for more detailed information about a specific directory tree space. The `du` command `-h` and `-H` options convert the output to a human-readable format. The du command shows the size of all files in the current directory tree recursively.

View the disk usage report for the /usr/share directory on the host machine:

```bash
du /usr/share
```

View the disk usage report in human-readable format for the /usr/share directory:

```bash
du -h /usr/share
```

# Mounting and Unmounting File Systems

## Mounting File Systems Manually

To access the file system on a removable storage device, you must mount the storage device. With the `mount` command, the root user can mount a file system manually. The first argument of the mount command specifies the file system to mount. The second argument specifies the directory as the mount point in the file-system hierarchy.

You can mount the file system in one of the following ways with the mount command:

- With the device file name in the /dev directory.
- With the UUID, a universally unique identifier of the device.

Then, identify the device to mount, ensure that the mount point exists, and mount the device on the mount point.

**Note**
If you mount a file system with the mount command, and then reboot your system, the file system is not automatically remounted. The Red Hat System Administration II (RH134) course explains how to persistently mount file systems with the `/etc/fstab` file

## Identifying a Block Device

A hot-pluggable storage device, whether a hard disk drive (HDD) or a solid-state device (SSD) in a server, or alternatively a USB storage device, might be plugged into a different port on a system each time. Use the `lsblk` command to list the details of a specified block device or of all the available devices.

```bash
lsblk
```
```bash
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda      8:0    0   10G  0 disk
├─sda1   8:1    0    1M  0 part
├─sda2   8:2    0  200M  0 part /boot/efi
└─sda3   8:3    0  9.8G  0 part /
sdb      8:16   0    5G  0 disk
sdc      8:32   0    5G  0 disk
sdd      8:48   0    5G  0 disk
sr0     11:0    1  514K  0 rom
```

The partition size helps to identify the device when the partition name is unknown. For example, considering the previous output, if the size of the identified partition is 9.8 GB, then mount the `/dev/sda3` partition.

## Mounting a File System with the Partition Name

The following example mounts the `/dev/sda3` partition on the `/mnt/data` mount point.

```bash
mount /dev/sda3 /mnt/data
```

The mount point directory must exist before mounting the file system. The /mnt directory exists for use as a temporary mount point.

**Important**
If a directory to use as a mount point is not empty, then the existing files are hidden and not accessible when a file system is mounted there. The original files are accessible again after the mounted file system is unmounted.

Device detection order and storage device naming can change when devices are added or removed on a system. A good practice is to use an unchanging device identifier to mount file systems consistently.

## Mounting a File System with Partition UUID

One stable identifier that is associated with a file system is its universally unique identifier (UUID). This UUID is stored in the file-system superblock and remains the same until the file system is re-created.

The `lsblk -fp` command lists the full path of the device, the UUIDs and mount points, and the partition's file-system type. The mount point is blank when the file system is not mounted.

```bash
lsblk -fp
```
Mount the file system by the file-system UUID.

```bash
mount UUID="15507695-22bb-4c65-94e6-a438e095983f" /mnt/data
```

## Automatically Mounting Removable Storage Devices

With the graphical desktop environment, the system automatically mounts removable storage media when the media presence is detected.

The removable storage device mounts at the `/run/media/USERNAME/LABEL` location. *USERNAME* is the name of the user that is logged in to the graphical environment. *LABEL* is an identifier, which is typically the label on the storage media.

To safely detach a removable device, manually unmount all file systems on the device first.

## Unmounting File Systems

System shutdown and reboot procedures are used to unmount all file systems automatically. All file-system data is flushed to the storage device, to ensure file-system data integrity.

**Warning**
File-system data uses memory cache during regular operation. You must unmount a removable drive's file systems before unplugging the drive. The unmount procedure flushes data to disk before releasing the drive.

The `umount` command uses the mount point as an argument to unmount a file system.

```bash
umount /mnt/data
```
Unmounting is not possible when the mounted file system is in use. For the umount command to succeed, all processes must stop accessing data under the mount point.

In the following example, the `umount` command fails because the shell uses the `/mnt/data` directory as its current working directory, and thus generates an error message.

```bash
cd /mnt/data
umount /mnt/data
```

The `lsof` command lists all open files and the processes that are accessing the file system. The list helps to identify which processes are preventing the file system from successfully unmounting.

```bash
lsof /mnt/data
```

Identify and wait for the processes to complete, or send the SIGTERM or SIGKILL signal to terminate them. In this case, you can change to a current working directory that is outside the mount point.

```bash
cd 
unmount /mnt/data
```